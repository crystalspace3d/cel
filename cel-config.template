lflags="-L${libdir}"

# From autoconf:
# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  echo "#! /bin/sh" >conf$$.sh
  echo  "exit 0"   >>conf$$.sh
  chmod +x conf$$.sh
  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
    PATH_SEPARATOR=';'
  else
    PATH_SEPARATOR=:
  fi
  rm -f conf$$.sh
fi

# If CEL set, prefer it over configure-time installation directory.
CEL="${CEL-${prefix}$PATH_SEPARATOR.}"
my_IFS=$IFS; IFS=$PATH_SEPARATOR
for p in $CEL
do
  prefix="${p}"
  exec_prefix="${prefix}"
  # try to determine if we're in a source or installed CS version
  if test "x$includedir" = "x"
  then
    if [ -r ${prefix}/include/${packagename}/physicallayer/pl.h ] ; then
      includedir="${prefix}/include/${packagename}"
    elif [ -r ${prefix}/include/physicallayer/pl.h ] ; then
      includedir="${prefix}/include"
    fi
  fi
done
IFS=$my_IFS
if test "x$includedir" = "x"
then
  includedir="${appincdir}"
fi
cflags="-I${includedir}"

# scan for optional libs
optsearch=""
my_IFS=$IFS; IFS=$PATH_SEPARATOR
for p in $CEL
do
  optsearch="$optsearch $p/$makeout/libs"
done
IFS=$my_IFS
optsearch="$optsearch $libdir"
for l in ${optlibs}
do
  for p in $optsearch
  do
    if test -r "$p/lib${l}.a"; then
      libs="$libs $l"
      exportsummary="$exportsummary $l $p"
      break
    fi
  done
done

showlibs ()
{
  echo "Libraries:"
  for lib in $libs; do
    echo "  $lib"
  done
  [ -z "$libs" ] && echo "No libraries available."
}

usage()
{
  cat <<__EOF__
Usage: cel-config [OPTIONS]
Options:
	[--prefix]
	[--exec-prefix]
	[--version]
	[--libs]
	[--cflags]
	[--lflags]
	[--plugindir]
	[--includedir]
	[--available-libs]
	[--static-deps]
	[--help]

__EOF__
  showlibs
  cat <<__EOF__

Note that you must also utilize the output of cs-config when compiling
CEL-using projects.
__EOF__
}

linkflags()
{
  # Detect type of the installation and the directories where the library files
  # reside in.
  entry_found="no"
  result=""

  for entry in ${exportsummary}; do
    if test "${entry_found}" = "yes" ; then 
      result=$entry
      break
    elif test "$1" = "$entry" ; then 
      entry_found="yes"
    fi
  done

  local newflag=""
  if test "${entry_found}" = "yes"; then
    if test -n "${result}"; then
      my_IFS=$IFS; IFS=$PATH_SEPARATOR
      for p in $CEL
      do
	if test -n "${p}" && test -d "${p}/${result}"; then
	  newflag="-L${p}/${result} "
	  break
	fi
      done
      IFS=$my_IFS
      if test -z "${newflag}" && test -d "${result}"; then
	newflag="-L${result} "
      fi
    fi
    echo "${newflag}-l$1"
  fi
}

staticdeps()
{
  local staticsearch=""
  local result=""
  
  my_IFS=$IFS; IFS=$PATH_SEPARATOR
  for p in $CEL
  do
    staticsearch="$staticsearch $p/$makeout/libs"
  done
  IFS=$my_IFS
  staticsearch="$staticsearch $libdir"
  
  for p in $staticsearch
  do
    if test -r "$p/$staticdeps"; then
      result="$p/$staticdeps"
      break
    fi
  done
  
  if test -n "${result}"; then
    # Prepare path returned by --static-deps - it'll be a MSYS style path, but
    # Jam needs a native Win32 path.
    if test "`uname -s | sed -e 's+\(.*\)_.*+\1+'`" = "MINGW32" ; then
      result=`echo $result | sed -e 's+^/\(.\)\(.*\)+\1:\2+'`
    fi
    echo "${result}"
  fi
}

my_IFS=$IFS; IFS=$PATH_SEPARATOR
for p in $CEL
do
    # If CEL is set and pointing at build directory, then prefer it over installed
    # version; else if CEL is set and pointing at installed location, then use it;
    # else use configure-time installation directory.
    if test -f "${p}/stdphyslayer.so" ||
       test -f "${p}/stdphyslayer.dll" ||
       test -f "${p}/stdphyslayer.csbundle"; then
	plugindir="${p}"
	break
    elif test -f "${p}/lib/cel/stdphyslayer.so" ||
       test -f "${p}/lib/cel/stdphyslayer.dll" ||
       test -f "${p}/lib/cel/stdphyslayer.csbundle"; then
	plugindir="${p}/lib/cel"
	break
    fi
done
IFS=$my_IFS

if test $# -eq 0; then
    usage 1>&2
    exit 1
fi

show_cflags=""
show_exec_prefix=""
show_includedir=""
show_lflags=""
show_libs=""
show_plugindir=""
show_prefix=""
show_version=""
while test $# -gt 0; do
  case $1 in
    --help)
	usage
	exit 0
	;;
    --prefix)
	show_prefix="yes"
	;;
    --exec-prefix)
	show_exec_prefix="yes"
	;;
    --version)
        show_version="yes"
        ;;
    --plugindir)
	show_plugindir="yes"
	;;
    --includedir)
	show_includedir="yes"
	;;
    --libs)
	show_libs="yes"
	;;
    --cflags)
        show_cflags="yes"
        ;;
    --lflags)
        show_lflags="yes"
        ;;
    --available-libs)
	show_availlibs=true
	;;
    --static-deps)
	staticdeps
	exit 0
	;;
    *)
	raw_names="$raw_names $1"
        ;;
  esac
  shift
done

if test -n "$show_prefix"; then
    echo "$prefix"
fi
if test -n "$show_exec_prefix"; then
    echo "$exec_prefix"
fi
if test -n "$show_version"; then
    echo "$version"
fi
if test -n "$show_plugindir"; then
    echo "$plugindir"
fi
if test -n "$show_includedir"; then
    echo "$includedir"
fi
if test -n "$show_cflags"; then
    echo "$cflags"
fi
if test -n "$show_libs"; then
    echo "$libs"
fi
if test -n "$show_lflags"; then
    # If user specified no libraries, then emit all.
    if test -z "$raw_names"; then
	raw_names=$libs
    fi
    for lib in $raw_names; do
	# We purposely prepend the new flags to ensure that older flags appear
	# toward this end.  This allows the linker to correctly prefer -L
	# options for the build directory over -L${libdir} for the installation
	# directory (i.e. prefer the current development version over an
	# installed version).
        lflags=`linkflags $lib`" $lflags"
    done
    echo "$lflags"
fi

if test -n "$show_availlibs"; then
    # If user specified no libraries, then emit all.
    if test -z "$raw_names"; then
	for x in $libs; do
	    echo $x
	done
    else
	# Filter the user-supplied list down to valid entries. 
	for x in $raw_names; do
	    for z in $libs; do
		if test "_$x" = "_$z"; then
		    echo $x
		    break
		fi
	    done
        done
    fi
fi

exit 0
