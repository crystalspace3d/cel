<world>
    <textures>
        <texture name="picture1">
	    <file>/cellib/images/to_the_tavern.jpg</file>
	    <keepimage />
        </texture>
        <texture name="leaves">
	    <file>/cellib/images/leaves.png</file>
	    <keepimage />
        </texture>
        <texture name="light_wood">
	    <file>/cellib/images/light_wood.png</file>
	    <keepimage />
        </texture>
        <texture name="dark_wood">
	    <file>/cellib/images/dark_wood.png</file>
	    <keepimage />
        </texture>
        <texture name="sand_stone">
	    <file>/cellib/images/sand_stone.png</file>
	    <keepimage />
        </texture>
        <texture name="marble">
	    <file>/cellib/images/marble.png</file>
	    <keepimage />
        </texture>
        <texture name="chocolate">
	    <file>/cellib/images/chocolate.png</file>
	    <keepimage />
        </texture>
        <texture name="slanted_stone">
	    <file>/cellib/images/slanted_stone.png</file>
	    <keepimage />
        </texture>
        <texture name="wood_box">
	    <file>/cellib/images/wood_box.png</file>
	    <keepimage />
        </texture>
        <texture name="hero">
	    <file>/cellib/images/hero.png</file>
	    <transparent red="1" green="1" blue="1" />
	    <keepimage />
        </texture>
        <texture name="monster">
	    <file>/cellib/images/monster.png</file>
	    <transparent red="1" green="1" blue="1" />
	    <keepimage />
        </texture>
        <texture name="apple">
	    <file>/cellib/images/apple.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="pear">
	    <file>/cellib/images/pear.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="banana">
	    <file>/cellib/images/banana.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="mushroom">
	    <file>/cellib/images/mushroom.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="diamond">
	    <file>/cellib/images/diamond.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="diamond_bomb">
	    <file>/cellib/images/diamond_bomb.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="bomb">
	    <file>/cellib/images/bomb.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="rock">
	    <file>/cellib/images/rock.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="black">
	    <file>/cellib/images/black.png</file>
	    <keepimage />
        </texture>
        <texture name="brick_full">
	    <file>/cellib/images/brick_full.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="brick_broken">
	    <file>/cellib/images/brick_broken.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>

        <texture name="explosion_c">
	    <file>/cellib/images/explosion_c.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_t">
	    <file>/cellib/images/explosion_t.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_l">
	    <file>/cellib/images/explosion_l.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_r">
	    <file>/cellib/images/explosion_r.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_b">
	    <file>/cellib/images/explosion_b.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_bl">
	    <file>/cellib/images/explosion_bl.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_br">
	    <file>/cellib/images/explosion_br.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_tl">
	    <file>/cellib/images/explosion_tl.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="explosion_tr">
	    <file>/cellib/images/explosion_tr.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>

        <texture name="fattube_lr">
	    <file>/cellib/images/fattube_lr.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_ud">
	    <file>/cellib/images/fattube_ud.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_lu">
	    <file>/cellib/images/fattube_lu.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_ld">
	    <file>/cellib/images/fattube_ld.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_ru">
	    <file>/cellib/images/fattube_ru.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_rd">
	    <file>/cellib/images/fattube_rd.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_lrud">
	    <file>/cellib/images/fattube_lrud.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="fattube_udlr">
	    <file>/cellib/images/fattube_udlr.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>

        <texture name="tube_lr">
	    <file>/cellib/images/tube_lr.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_ud">
	    <file>/cellib/images/tube_ud.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_lu">
	    <file>/cellib/images/tube_lu.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_ld">
	    <file>/cellib/images/tube_ld.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_ru">
	    <file>/cellib/images/tube_ru.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_rd">
	    <file>/cellib/images/tube_rd.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_lrd">
	    <file>/cellib/images/tube_lrd.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_lru">
	    <file>/cellib/images/tube_lru.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_lud">
	    <file>/cellib/images/tube_lud.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_rud">
	    <file>/cellib/images/tube_rud.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_lrud">
	    <file>/cellib/images/tube_lrud.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_and">
	    <file>/cellib/images/tube_and.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_or">
	    <file>/cellib/images/tube_or.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_xor">
	    <file>/cellib/images/tube_xor.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_power">
	    <file>/cellib/images/tube_power.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_power_25">
	    <file>/cellib/images/tube_power_25.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_power_50">
	    <file>/cellib/images/tube_power_50.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_power_75">
	    <file>/cellib/images/tube_power_75.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_power_full">
	    <file>/cellib/images/tube_power_full.png</file>
	    <keepimage />
        </texture>
        <texture name="doorred">
	    <file>/cellib/images/doorred.png</file>
	    <keepimage />
        </texture>
        <texture name="doorgreen">
	    <file>/cellib/images/doorgreen.png</file>
	    <keepimage />
        </texture>
        <texture name="doorblue">
	    <file>/cellib/images/doorblue.png</file>
	    <keepimage />
        </texture>
        <texture name="dooryellow">
	    <file>/cellib/images/dooryellow.png</file>
	    <keepimage />
        </texture>
        <texture name="dooropen">
	    <file>/cellib/images/dooropen.png</file>
	    <keepimage />
        </texture>
        <texture name="redkey">
	    <file>/cellib/images/redkey.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="bluekey">
	    <file>/cellib/images/bluekey.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="greenkey">
	    <file>/cellib/images/greenkey.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="yellowkey">
	    <file>/cellib/images/yellowkey.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="tube_redkey">
	    <file>/cellib/images/tube_redkey.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_bluekey">
	    <file>/cellib/images/tube_bluekey.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_greenkey">
	    <file>/cellib/images/tube_greenkey.png</file>
	    <keepimage />
        </texture>
        <texture name="tube_yellowkey">
	    <file>/cellib/images/tube_yellowkey.png</file>
	    <keepimage />
        </texture>
        <texture name="arrow_r">
	    <file>/cellib/images/arrow_r.png</file>
	    <keepimage />
        </texture>
        <texture name="arrow_l">
	    <file>/cellib/images/arrow_l.png</file>
	    <keepimage />
        </texture>
        <texture name="arrow_u">
	    <file>/cellib/images/arrow_u.png</file>
	    <keepimage />
        </texture>
        <texture name="arrow_d">
	    <file>/cellib/images/arrow_d.png</file>
	    <keepimage />
        </texture>

        <texture name="save">
	    <file>/cellib/images/save.png</file>
	    <keepimage />
        </texture>
        <texture name="number_0">
	    <file>/cellib/images/number_0.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_1">
	    <file>/cellib/images/number_1.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_2">
	    <file>/cellib/images/number_2.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_3">
	    <file>/cellib/images/number_3.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_4">
	    <file>/cellib/images/number_4.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_5">
	    <file>/cellib/images/number_5.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_6">
	    <file>/cellib/images/number_6.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_7">
	    <file>/cellib/images/number_7.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_8">
	    <file>/cellib/images/number_8.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
        <texture name="number_9">
	    <file>/cellib/images/number_9.png</file>
	    <transparent red="0" green="0" blue="0" />
	    <keepimage />
        </texture>
    </textures>
    <materials>
	<material name="picture1"> <texture>picture1</texture> </material>
        <material name="leaves"> <texture>leaves</texture> </material>
        <material name="light_wood"> <texture>light_wood</texture> </material>
        <material name="dark_wood"> <texture>dark_wood</texture> </material>
        <material name="sand_stone"> <texture>sand_stone</texture> </material>
        <material name="marble"> <texture>marble</texture> </material>
        <material name="chocolate"> <texture>chocolate</texture> </material>
        <material name="slanted_stone"> <texture>slanted_stone</texture> </material>
        <material name="wood_box"> <texture>wood_box</texture> </material>
        <material name="hero"> <texture>hero</texture> </material>
        <material name="monster"> <texture>monster</texture> </material>
        <material name="apple"> <texture>apple</texture> </material>
        <material name="pear"> <texture>pear</texture> </material>
        <material name="banana"> <texture>banana</texture> </material>
        <material name="mushroom"> <texture>mushroom</texture> </material>
        <material name="diamond"> <texture>diamond</texture> </material>
        <material name="diamond_bomb"> <texture>diamond_bomb</texture> </material>
        <material name="bomb"> <texture>bomb</texture> </material>
        <material name="rock"> <texture>rock</texture> </material>
        <material name="brick_full"> <texture>brick_full</texture> </material>
        <material name="brick_broken"> <texture>brick_broken</texture> </material>
        <material name="black"> <texture>black</texture> </material>
        <material name="explosion_c"> <texture>explosion_c</texture> </material>
        <material name="explosion_b"> <texture>explosion_b</texture> </material>
        <material name="explosion_t"> <texture>explosion_t</texture> </material>
        <material name="explosion_r"> <texture>explosion_r</texture> </material>
        <material name="explosion_l"> <texture>explosion_l</texture> </material>
        <material name="explosion_bl"> <texture>explosion_bl</texture> </material>
        <material name="explosion_br"> <texture>explosion_br</texture> </material>
        <material name="explosion_tl"> <texture>explosion_tl</texture> </material>
        <material name="explosion_tr"> <texture>explosion_tr</texture> </material>
        <material name="fattube_lr"> <texture>fattube_lr</texture> </material>
        <material name="fattube_ud"> <texture>fattube_ud</texture> </material>
        <material name="fattube_lu"> <texture>fattube_lu</texture> </material>
        <material name="fattube_ld"> <texture>fattube_ld</texture> </material>
        <material name="fattube_ru"> <texture>fattube_ru</texture> </material>
        <material name="fattube_rd"> <texture>fattube_rd</texture> </material>
        <material name="fattube_lrud"> <texture>fattube_lrud</texture> </material>
        <material name="fattube_udlr"> <texture>fattube_udlr</texture> </material>
        <material name="tube_lr"> <texture>tube_lr</texture> </material>
        <material name="tube_ud"> <texture>tube_ud</texture> </material>
        <material name="tube_lu"> <texture>tube_lu</texture> </material>
        <material name="tube_ld"> <texture>tube_ld</texture> </material>
        <material name="tube_ru"> <texture>tube_ru</texture> </material>
        <material name="tube_rd"> <texture>tube_rd</texture> </material>
        <material name="tube_lrd"> <texture>tube_lrd</texture> </material>
        <material name="tube_lru"> <texture>tube_lru</texture> </material>
        <material name="tube_lud"> <texture>tube_lud</texture> </material>
        <material name="tube_rud"> <texture>tube_rud</texture> </material>
        <material name="tube_lrud"> <texture>tube_lrud</texture> </material>
        <material name="tube_and"> <texture>tube_and</texture> </material>
        <material name="tube_or"> <texture>tube_or</texture> </material>
        <material name="tube_xor"> <texture>tube_xor</texture> </material>
        <material name="tube_power"> <texture>tube_power</texture> </material>
        <material name="tube_power_25"> <texture>tube_power_25</texture> </material>
        <material name="tube_power_50"> <texture>tube_power_50</texture> </material>
        <material name="tube_power_75"> <texture>tube_power_75</texture> </material>
        <material name="tube_power_full"> <texture>tube_power_full</texture> </material>
        <material name="doorred"> <texture>doorred</texture> </material>
        <material name="doorgreen"> <texture>doorgreen</texture> </material>
        <material name="doorblue"> <texture>doorblue</texture> </material>
        <material name="dooryellow"> <texture>dooryellow</texture> </material>
        <material name="dooropen"> <texture>dooropen</texture> </material>
        <material name="redkey"> <texture>redkey</texture> </material>
        <material name="greenkey"> <texture>greenkey</texture> </material>
        <material name="bluekey"> <texture>bluekey</texture> </material>
        <material name="yellowkey"> <texture>yellowkey</texture> </material>
        <material name="tube_redkey"> <texture>tube_redkey</texture> </material>
        <material name="tube_greenkey"> <texture>tube_greenkey</texture> </material>
        <material name="tube_bluekey"> <texture>tube_bluekey</texture> </material>
        <material name="tube_yellowkey"> <texture>tube_yellowkey</texture> </material>
        <material name="arrow_l"> <texture>arrow_l</texture> </material>
        <material name="arrow_r"> <texture>arrow_r</texture> </material>
        <material name="arrow_u"> <texture>arrow_u</texture> </material>
        <material name="arrow_d"> <texture>arrow_d</texture> </material>
        <material name="save"> <texture>save</texture> </material>
        <material name="number_0"> <texture>number_0</texture> </material>
        <material name="number_1"> <texture>number_1</texture> </material>
        <material name="number_2"> <texture>number_2</texture> </material>
        <material name="number_3"> <texture>number_3</texture> </material>
        <material name="number_4"> <texture>number_4</texture> </material>
        <material name="number_5"> <texture>number_5</texture> </material>
        <material name="number_6"> <texture>number_6</texture> </material>
        <material name="number_7"> <texture>number_7</texture> </material>
        <material name="number_8"> <texture>number_8</texture> </material>
        <material name="number_9"> <texture>number_9</texture> </material>
    </materials>
    <sounds>
        <sound name="boing"> <file>/cellib/sounds/boing_x.wav</file> </sound>
        <sound name="click"> <file>/cellib/sounds/click_x.wav</file> </sound>
        <sound name="yay"> <file>/cellib/sounds/yay_x.wav</file> </sound>
        <sound name="clang"> <file>/cellib/sounds/clang_x.wav</file> </sound>
        <sound name="bloop"> <file>/cellib/sounds/bloop_x.wav</file> </sound>
        <sound name="explosion"> <file>/cellib/sounds/explosion_x.wav</file> </sound>
    </sounds>
    <settings>
        <clearscreen>yes</clearscreen>
        <clearzbuf>yes</clearzbuf>
    </settings>
    <plugins>
        <plugin name="celentity">cel.addons.celentity</plugin>
        <plugin name="xmlscripts">cel.addons.xmlscripts</plugin>
    </plugins>

    <addon plugin="xmlscripts">
        <pcfactory>cel.pcfactory.mesh</pcfactory>
        <pcfactory>cel.pcfactory.solid</pcfactory>
        <pcfactory>cel.pcfactory.gravity</pcfactory>
        <pcfactory>cel.pcfactory.movable</pcfactory>
        <pcfactory>cel.pcfactory.billboard</pcfactory>
        <pcfactory>cel.pcfactory.properties</pcfactory>
        <pcfactory>cel.pcfactory.timer</pcfactory>
        <pcfactory>cel.pcfactory.inventory</pcfactory>
        <pcfactory>cel.pcfactory.pckeyinput</pcfactory>

	<!-- *****************************************************
	  - This script handles the menu system of xmlgames.
	  -  ***************************************************** -->
	<script name="menu">
	    <!--
	      - Initialization.
	      -->
	    <event name="init">
	        <print value="'Start initializing menu...'" />

		<!-- Puzzle game button -->
		<var name="material" value="picture1" />
		<createentity name="puzzle_button" behaviour="game_button" />
		<default propclass="pc(puzzle_button,pcbillboard)" />
	        <property id="propid(x)" value="10000" />
	        <property id="propid(y)" value="10000" />
		<var entity="puzzle_button" name="game" value="puzzle_main" />
		<var entity="puzzle_button" name="game_bh" value="puzzle_main" />

		<!-- Maze game button -->
		<var name="material" value="apple" />
		<createentity name="maze_button" behaviour="game_button" />
		<default propclass="pc(maze_button,pcbillboard)" />
	        <property id="propid(x)" value="10000" />
	        <property id="propid(y)" value="70000" />
		<var entity="maze_button" name="game" value="maze_main" />
		<var entity="maze_button" name="game_bh" value="maze_main" />

		<!-- Boulderdash game button -->
		<var name="material" value="slanted_stone" />
		<createentity name="bdash_button" behaviour="game_button" />
		<default propclass="pc(bdash_button,pcbillboard)" />
	        <property id="propid(x)" value="10000" />
	        <property id="propid(y)" value="130000" />
		<var entity="bdash_button" name="game" value="bdash_main" />
		<var entity="bdash_button" name="game_bh" value="bdash_main" />

		<!-- Boulderdash game edit button -->
		<var name="material" value="slanted_stone" />
		<createentity name="bdashedit_button" behaviour="game_button" />
		<default propclass="pc(bdashedit_button,pcbillboard)" />
	        <property id="propid(x)" value="130000" />
	        <property id="propid(y)" value="130000" />
		<var entity="bdashedit_button" name="game" value="bdash_main" />
		<var entity="bdashedit_button" name="game_bh" value="bdashedit_main" />
	    </event>

	    <!--
	      - Call this event to start a game. This will destroy the menu
	      - and create the game entity. Needs the ?game variable to be
	      - set to the name of the game (the button will do that).
	      -->
	    <event name="startgame">
	        <print value="'Start destroying menu...'" />
	        <destroyentity name="puzzle_button" />
	        <destroyentity name="maze_button" />
	        <destroyentity name="bdash_button" />
	        <destroyentity name="bdashedit_button" />
		<createentity name="?game" behaviour="?game_bh" />
	    </event>
	</script>

	<!-- *****************************************************
	  - Generic back button handler for returning to the main menu.
	  - Users of this behaviour should set the 'game_entity' variable
	  - of the entity which controls this script to the entity controlling
	  - the game. It will call 'destroy' on that entity as soon as
	  - the button is clicked.
	  -  ***************************************************** -->
        <script name="back_button">
	    <!--
	      - Initialize the back button.
	      -->
	    <event name="init">
	        <createpropclass name="pcbillboard" />
	        <createpropclass name="pcproperties" />
		<default propclass="pc(pcbillboard)" />
	        <property id="propid(name)" value="picture1" />
	        <property id="propid(materialname)" value="picture1" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="true" />
	        <property id="propid(restack)" value="true" />
	        <property id="propid(width)" value="20000" />
	        <property id="propid(height)" value="20000" />
	        <property id="propid(x)" value="295000" />
	        <property id="propid(y)" value="100" />
	    </event>

	    <!--
	      - Go to the main menu.
	      -->
	    <event name="pcbillboard_select">
		<call event="destroygame" />
		<call entity="menu" event="init" />
		<destroyentity name="?game_entity" />
	    </event>

	    <!--
	      - Destroy all resources created by the current game.
	      -->
	    <event name="destroygame">
	        <print value="'Start destroying game...'" />
		<inventory propclass="pc(?game_entity,pcinventory)" />
		<while eval="inventory_count()>0" >
		    <var name="child" value="inventory_get(0)" />
		    <print value="'    destroy '+?child" />
		    <inventory_rem child="?child" />
		    <destroyentity name="?child" />
		</while>
	    </event>

	</script>

	<!-- *****************************************************
	  - This script handles the button for a game.
	  - Needs the ?menu.material variable for the material of
	  - the button.
	  -  ***************************************************** -->
	<script name="game_button">
	    <!--
	      - Initialization.
	      -->
	    <event name="init">
	        <createpropclass name="pcbillboard" />
	        <createpropclass name="pcproperties" />
		<default propclass="pc(pcbillboard)" />
	        <property id="propid(name)" value="picture1" />
	        <property id="propid(materialname)" value="?menu.material" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="true" />
	        <property id="propid(restack)" value="true" />
	        <property id="propid(width)" value="50000" />
	        <property id="propid(height)" value="50000" />
	    </event>

	    <!--
	      - Select this button. Fire up the right game.
	      -->
	    <event name="pcbillboard_select">
	    	<sound name="boing" loop="false" />
		<var entity="menu" name="game" value="?game" />
		<var entity="menu" name="game_bh" value="?game_bh" />
	        <call entity="menu" event="startgame" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script is the superclass of moving objects. You cannot
	  - use this script standalone.
	  - This script uses the following variables:
	  -    ?x,?y: block position of object
	  -    ?speed: speed of movement
	  -    ?dim: dimension of objects.
	  -  ***************************************************** -->
	<script name="movingobject">
	    <!--
	      - Initialize. Needs parameter ?material for the material name,
	      - ?x, ?y for the position, and ?dim for the dimension of the
	      - objects.
	      -->
	    <event name="init">
	        <createpropclass name="pctimer" />
	        <createpropclass name="pcbillboard" />
		<var name="pcbb" value="pc(pcbillboard)" />
		<default propclass="?pcbb" />
	        <property id="propid(name)" value="?material" />
	        <property id="propid(materialname)" value="?material" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="true" />
	        <property id="propid(restack)" value="false" />
	        <property id="propid(width)" value="?dim" />
	        <property id="propid(height)" value="?dim" />
	        <property id="propid(x)" value="?x*?dim" />
	        <property id="propid(y)" value="?y*?dim" />
		<var name="moving" value="false" />
	    </event>

	    <!--
	      - For debugging: show variables.
	      -->
	    <event name="pcbillboard_select">
	    	<variables />
	    </event>

	    <!--
	      - Routine to calculate ?dx and ?dy based on ?dxdy.
	      -->
	    <event name="calcdxdy">
		<!-- Set ?dx and ?dy based on the four possible outcomes -->
		<if eval="?dxdy&2">
		    <true>
		        <var name="dx" value="0" />
		        <var name="dy" value="if(?dxdy&1,1,-1)" />
		    </true>
		    <false>
		        <var name="dx" value="if(?dxdy&1,1,-1)" />
		        <var name="dy" value="0" />
		    </false>
		</if>
	    </event>

	    <!--
	      - The move ends.
	      -->
	    <event name="pctimer_wakeup">
	        <if eval="?moving">
		    <var name="moving" value="false" />
		    <call event="endmove" />
		</if>
	    </event>

	    <!--
	      - End movement.
	      -->
	    <event name="endmove">
		<action propclass="pc(pctimer)" id="propid(Clear)" />
	    </event>

	    <!--
	      - Start a movement in ?dx,?dy direction.
	      -->
	    <event name="startmove">
		<var name="x" value="?x+?dx" />
		<var name="y" value="?y+?dy" />
		<var name="moving" value="true" />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="int(1000*?speed)" />
		    <par id="parid(repeat)" value="false" />
		</action>
		<bb_move x="?x*?dim" y="?y*?dim" delta="int(1000*?speed)" />
	    </event>
	</script>

	<!-- *****************************************************
	  - Number!
	  -  ***************************************************** -->
	<script name="number">
	    <!--
	      - Initialize.
	      -->
	    <event name="init">
	        <createpropclass name="pcbillboard" />
		<var name="pcbb" value="pc(pcbillboard)" />
		<default propclass="?pcbb" />
	    </event>

	    <!--
	      - Initialize. Needs parameter @material.
	      -->
	    <event name="realinit">
		<default propclass="?pcbb" />
	        <property id="propid(name)" value="number" />
	        <property id="propid(materialname)" value="@material" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="false" />
	        <property id="propid(restack)" value="false" />
	        <property id="propid(visible)" value="false" />
	        <property id="propid(width)" value="18000" />
	        <property id="propid(height)" value="18000" />
	        <property id="propid(x)" value="1000" />
	        <property id="propid(y)" value="1000" />
	    </event>

	    <event name="show">
		<default propclass="?pcbb" />
		<bb_tofront />
	        <property id="propid(visible)" value="true" />
	        <property id="propid(x)" value="@x" />
	        <property id="propid(y)" value="@y" />
	    </event>
	    <event name="hide">
		<default propclass="?pcbb" />
	        <property id="propid(visible)" value="false" />
	    </event>
	</script>

	<!-- *****************************************************
	  - Generic superclass for games that can keep track of score and print it.
	  -  ***************************************************** -->
	<script name="supergame">
	    <event name="init">
		<inventory propclass="pc(pcinventory)" />
		<for var="i" start="0" end="6">
		    <for var="d" start="0" end="9">
		    	<lvar name="entname" value="number+?i+'_'+?d" />
		        <createentity name="#entname" behaviour="number" />
			<lvar name="ent" value="ent(#entname)" />
			<call entity="#ent" event="realinit">
			    <par id="parid(material)" value="number_+?d" />
			</call>
			<inventory_add child="#ent" />
		    </for>
		</for>
	    	<call event="clearscore" />
	    </event>

	    <event name="clearscore">
	        <var name="score" value="0" />
		<call event="constructscore" />
	    </event>

	    <!--
	      - Add to a score (can be negative).
	      - Parameter is @score.
	      -->
	    <event name="addscore">
	    	<call event="hidescore" />
	        <var name="score" value="?score+@score" />
		<if eval="?score < 0">
	            <var name="score" value="0" />
		</if>
		<call event="constructscore" />
	    </event>

	    <event name="hidescore">
		<lvar name="s" value="?score" />
		<lvar name="i" value="0" />
		<while eval="#s>=0">
		    <lvar name="d" value="#s%10" />
		    <lvar name="s" value="#s/10" />
		    <call entity="ent(number+#i+'_'+#d)" event="hide" />
		    <lvar name="i" value="#i+1" />
		    <if eval="!#s"> <stop /> </if>
		</while>
	    </event>

	    <event name="constructscore">
	        <lvar name="x" value="280000" />
	        <lvar name="y" value="280000" />
		<lvar name="s" value="?score" />
		<lvar name="i" value="0" />
		<while eval="#s>=0">
		    <lvar name="d" value="#s%10" />
		    <lvar name="s" value="#s/10" />
		    <call entity="ent(number+#i+'_'+#d)" event="show">
		        <par id="parid(x)" value="#x" />
		        <par id="parid(y)" value="#y" />
		    </call>
		    <lvar name="x" value="#x-18000" />
		    <lvar name="i" value="#i+1" />
		    <if eval="!#s"> <stop /> </if>
		</while>
	    </event>
	</script>

	<!-- *****************************************************
	  -  *****************************************************
	  - This is the puzzle game script.
	  -  *****************************************************
	  -  ***************************************************** -->
	<script name="puzzle_main">
	    <!--
	      - Initialize the puzzle game.
	      - The main puzzle entity maintains various variables to
	      - keep board state:
	      -    - grid<x>_<y>: an 2D array containing the name of the tile entity
	      -      at location x,y. Or '' if this is the empty tile.
	      -    - emptyx, emptyy: the location of the empty tile.
	      -    - allowmove: if true the player can move tiles.
	      -    - shuffle_count: if greater than 0 then we are randomizing the board.
	      -    - speed: a float indicating the speed with which tiles should move.
	      -    - dimension: the board size.
	      -    - tiledim: size of one tile.
	      -    - tiledimuv: size of one tile in texture coordinates.
	      -->
	    <event name="init">
	        <createpropclass name="pcinventory" />

		<!-- Set some defaults -->
		<!--
		<var name="dimension" value="4" />
		<var name="tiledim" value="70000" />
		<var name="tiledimuv" value=".25" />
		<var name="shuffle_count" value="30" />
		-->
		<var name="dimension" value="5" />
		<var name="tiledim" value="56000" />
		<var name="tiledimuv" value=".2" />
		<var name="shuffle_count" value="50" />

		<!-- Create the menu back button -->
		<createentity name="back_button" behaviour="back_button" />
		<var entity="back_button" name="game_entity" value="ent()" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="back_button" />

		<!-- Create the tiles of the board -->
	        <var name="uvtl" value="[0,0]" />
		<for var="y" start="0" end="?dimension-1">
		    <for var="x" start="0" end="?dimension-1" exec="inittile" />
	        </for>

		<!-- Clear the item at 0,0. This is the empty tile -->
		<property propclass="pc(p0_0,pcbillboard)"
			id="propid(visible)" value="false" />
		<property propclass="pc(p0_0,pcbillboard)"
			id="propid(clickable)" value="false" />
	        <var name="'grid_'+0+'_'+0" value="''" />
	        <var name="emptyx" value="0" />
	        <var name="emptyy" value="0" />

		<var name="speed" value="0.03" />
		<var name="allowmove" value="false" />
		<!-- Start randomizing -->
		<var name="prev_dxdy" value="1" />
		<call event="fast_shuffle" />
	    </event>

	    <!--
	      - Initialize one tile. This will create the entity representing
	      - the tile and it will set it at the right position on the puzzle
	      - board.
	      - This event uses ?x and ?y which should be set outside this routine.
	      - It also uses ?uvtl for the texture mapping coordinates.
	      -->
	    <event name="inittile">
	        <var name="ent" value="'p'+?x+'_'+?y" />
		<print value="'Creating '+?ent" />
		<createentity name="?ent" behaviour="moving_tile" />
		<var name="ent" value="ent(?ent)" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="?ent" />
		<default propclass="pc(?ent,pcbillboard)" />
	        <property id="propid(x)" value="1000+?tiledim*?x" />
	        <property id="propid(y)" value="1000+?tiledim*?y" />
		<var name="tl" value="[?x,?y]*?tiledimuv" />
	        <property id="propid(uv_topleft)" value="?tl" />
	        <property id="propid(uv_botright)" value="?tl+[?tiledimuv,?tiledimuv]" />
		<!-- Set the 2d grid to contain the current entity -->
	        <var name="'grid_'+?x+'_'+?y" value="?ent" />
	    </event>

	    <!--
	      - This routine is responsible for initiating a random move to
	      - randomize the board. The tile that moved will itself call this
	      - routine again if ?shuffle_count > 0. This routine will make sure
	      - that a tile doesn't move to where it was before. It uses
	      - ?prev_dxdy to do that.
	      -->
	    <event name="fast_shuffle">
	    	<!-- Try one of the four possible directions -->
	        <var name="dxdy" value="int(rand(4.0))" />
		<!-- If the direction is the opposite of the previous direction
		     we change it -->
		<var name="dxdy"
		    value="if(?prev_dxdy==(?dxdy^1),(?dxdy+1)%4,?dxdy)" />
		<var name="prev_dxdy" value="?dxdy" />
		<!-- Set ?dx and ?dy based on the four possible outcomes -->
		<if eval="?dxdy&2">
		    <true>
		        <var name="dx" value="0" />
		        <var name="dy" value="if(?dxdy&1,1,-1)" />
		    </true>
		    <false>
		        <var name="dx" value="if(?dxdy&1,1,-1)" />
		        <var name="dy" value="0" />
		    </false>
		</if>
		<!-- Location of the tile we want to move -->
		<var name="bx" value="?emptyx+?dx" />
		<var name="by" value="?emptyy+?dy" />
		<!-- Check if this is a valid location. If so we move it -->
		<if eval="?bx < ?dimension && ?bx >= 0 && ?by < ?dimension && ?by >= 0">
		    <true>
		        <var name="ent" value="?grid[?bx,?by]" />
		        <var entity="?ent" name="dx" value="-?dx" />
		        <var entity="?ent" name="dy" value="-?dy" />
			<call entity="?ent" event="move" />
		    </true>
		    <false>
		    	<!-- Try again -->
		        <call event="fast_shuffle" />
		    </false>
		</if>
	    </event>

	    <!--
	      - Start the game for real.
	      -->
	    <event name="start_game">
		<var name="speed" value="0.01" />
	        <var name="allowmove" value="true" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a tile in the puzzle game.
	  -  ***************************************************** -->
        <script name="moving_tile">
	    <!--
	      - Initialize this tile.
	      - It assumes ?puzzle_main.x and ?puzzle_main.y are set to the
	      - location of the tile.
	      -->
	    <event name="init">
	    	<!-- Create timer so we can do smooth movement of this tile -->
	        <createpropclass name="pctimer" />
	        <createpropclass name="pcbillboard" />
		<default propclass="pc(pcbillboard)" />
	        <property id="propid(name)" value="picture1" />
	        <property id="propid(materialname)" value="picture1" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="true" />
	        <property id="propid(restack)" value="true" />
	        <property id="propid(width)" value="?puzzle_main.tiledim" />
	        <property id="propid(height)" value="?puzzle_main.tiledim" />
		<var name="rightx" value="?puzzle_main.x" />
		<var name="righty" value="?puzzle_main.y" />
		<var name="curx" value="?rightx" />
		<var name="cury" value="?righty" />
	    </event>

	    <!--
	      - If this tile is moving then this event will be triggered
	      - every frame. Here we check how much time has elapsed and
	      - move the tile accordingly. If the tile has reached its
	      - destination then we call 'stoptimer'.
	      - The global ?puzzle_main.speed variable is used to control
	      - movement speed.
	      -->
	    <event name="pctimer_wakeupframe">
		<bb_move x="1000+intpol(?delta,?intx1,?intx2)*?puzzle_main.tiledim"
			 y="1000+intpol(?delta,?inty1,?inty2)*?puzzle_main.tiledim" />
		<if eval="?delta>=1" true="stoptimer" />
		<var name="delta" value="?delta+?puzzle_main.speed*@elapsedticks" />
	    </event>

	    <!--
	      - The tile has moved its destination. Stop the timer.
	      - If we are in shuffle mode (i.e. randomizing the board) then
	      - we signal the main 'puzzle_main' entity to start moving another
	      - tile. Otherwise we set ?puzzle_main.allowmove to true so that
	      - the player can move another tile.
	      -->
	    <event name="stoptimer">
		<action propclass="pc(pctimer)" id="propid(Clear)" />
		<bb_move x="1000+?curx*?puzzle_main.tiledim"
	        	 y="1000+?cury*?puzzle_main.tiledim" />
		<if eval="?puzzle_main.shuffle_count>0">
		    <true>
		        <var entity="puzzle_main" name="shuffle_count"
				value="?puzzle_main.shuffle_count-1" />
		        <call entity="puzzle_main" event="fast_shuffle" />
		    </true>
		    <false>
		    	<call entity="puzzle_main" event="start_game" />
		    </false>
		</if>
	    </event>

	    <!--
	      - Initiate the move of this tile to the location specified
	      - by local variables ?dx and ?dy. Doing this will disable
	      - other moves.
	      -->
	    <event name="move">
		<var entity="puzzle_main" name="allowmove" value="false" />
		<var entity="puzzle_main" name="emptyx" value="?curx" />
		<var entity="puzzle_main" name="emptyy" value="?cury" />
		<var name="intx1" value="float(?curx)" />
		<var name="inty1" value="float(?cury)" />
		<!-- Make current grid item empty -->
	        <var entity="puzzle_main" name="'grid_'+?curx+'_'+?cury"
			value="''" />
		<var name="curx" value="?curx+?dx" />
		<var name="cury" value="?cury+?dy" />
		<!-- Fill new grid item with current entity -->
	        <var entity="puzzle_main" name="'grid_'+?curx+'_'+?cury"
			value="ent()" />
		<var name="intx2" value="float(?curx)" />
		<var name="inty2" value="float(?cury)" />
		<var name="delta" value="0.0" />
		<action propclass="pc(pctimer)" id="propid(WakeUpFrame)" />
	    </event>

	    <!--
	      - Select this tile. If movement is allowed then this will
	      - check if the empty location is next to this block and if
	      - so it will call 'move' to initiate the movement.
	      -->
	    <event name="pcbillboard_select">
	        <if eval="?puzzle_main.allowmove">
		    <var name="dx" value="?puzzle_main.emptyx-?curx" />
		    <var name="dy" value="?puzzle_main.emptyy-?cury" />
		    <if eval="(abs(?dx)==1&&?dy==0)||(abs(?dy)==1&&?dx==0)">
	    	        <sound name="click" loop="false" />
			<call event="move"/>
		    </if>
		</if>
	    </event>
	</script>

	<!-- *****************************************************
	  -  *****************************************************
	  - This is the maze game script.
	  -  *****************************************************
	  -  ***************************************************** -->
	<script name="maze_main">
	    <event name="init">
	        <print value="MAZE"/>
	        <createpropclass name="pcinventory" />
	        <createpropclass name="pctimer" />

		<!-- Set some defaults -->
		<var name="dimension" value="16" />
		<var name="blockdim" value="18000" />
		<var name="herospeed" value=".1" />
		<var name="monsterspeed" value=".4" />
		<var name="fruitspeed" value=".4" />
		<var name="fruitmax" value="5" />
		<var name="fruitcnt" value="0" />
		<var name="monstercnt" value="2" />

		<!-- Create the menu back button -->
		<createentity name="back_button" behaviour="back_button" />
		<var entity="back_button" name="game_entity" value="ent()" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="back_button" />

		<!--  Create the maze -->
		<var name="row0"  value="'BBBBBBBBBBBBBBBB'" />
		<var name="row1"  value="'B      B       B'" />
		<var name="row2"  value="'B BBBB B BBBBB B'" />
		<var name="row3"  value="'B B    B B   B B'" />
		<var name="row4"  value="'B B B BB B B B B'" />
		<var name="row5"  value="'B B B B    BBB B'" />
		<var name="row6"  value="'B   B B B      B'" />
		<var name="row7"  value="'BBBBB   B BBBBBB'" />
		<var name="row8"  value="'B     BBB B    B'" />
		<var name="row9"  value="'B BBBBB   BB B B'" />
		<var name="row10" value="'B B     B  B B B'" />
		<var name="row11" value="'B BB BB BB B B B'" />
		<var name="row12" value="'B B   B B    B B'" />
		<var name="row13" value="'B BBBBB B BBBB B'" />
		<var name="row14" value="'B       B      B'" />
		<var name="row15" value="'BBBBBBBBBBBBBBBB'" />
		<for var="y" start="0" end="?dimension-1">
		    <var name="row" value="?(row+?y)" />
		    <for var="x" start="0" end="?dimension-1">
		        <var name="maze_+?x+'_'+?y" value="strsub(?row,?x,1)" />
		        <if eval="?maze[?x,?y]=='B'" true="initblock" />
		    </for>
		</for>

		<createentity name="hero" behaviour="maze_hero" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="hero" />
		<for var="i" start="1" end="?monstercnt">
		    <createentity name="monster+?i" behaviour="monster" />
		    <var name="bb_monster+?i" value="pc(monster+?i,pcbillboard)" />
		    <inventory propclass="pc(pcinventory)" />
		    <inventory_add child="monster+?i" />
		</for>

		<!-- Every second we check if we need to create a piece of fruit -->
		<var name="fruitidx" value="0" />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="1000" />
		    <par id="parid(repeat)" value="true" />
		</action>
	    </event>

	    <!--
	      - Initialize one block. This will create the entity representing
	      - the block and it will set it at the right position on the puzzle
	      - board.
	      - This event uses ?x and ?y which should be set outside this routine.
	      -->
	    <event name="initblock">
	        <var name="ent" value="'p'+?x+'_'+?y" />
		<print value="'Creating '+?ent" />
		<createentity name="?ent" behaviour="maze_block" />
		<var name="ent" value="ent(?ent)" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="?ent" />
	    </event>

	    <!--
	      - Create a new piece of fruit.
	      - Uses ?fruitidx to have unique entity names for fruit.
	      - Also uses ?fruitmax and ?fruitcnt to make sure there is
	      - not too much fruit on screen.
	      -->
	    <event name="pctimer_wakeup">
	        <if eval="?fruitcnt<?fruitmax && rand(8)>5">
		    <createentity name="fruit+?fruitidx" behaviour="fruit" />
		    <inventory propclass="pc(pcinventory)" />
		    <inventory_add child="fruit+?fruitidx" />
		    <var name="fruitidx" value="?fruitidx+1" />
		    <var name="fruitcnt" value="?fruitcnt+1" />
		</if>
	    </event>
	</script>

	<!-- *****************************************************
	  - This is a superscript for automatic moving objects in the
	  - maze game.
	  -  ***************************************************** -->
	<script name="automovingobject">
	    <superscript name="movingobject" />

	    <!--
	      - Initialize this moving object.
	      -->
	    <event name="init">
		<super />
	    	<!-- Init to one of the four possible directions -->
	        <var name="dxdy" value="int(rand(4.0))" />
		<call event="calcdxdy" />

		<call event="endmove" />
	    </event>

	    <!--
	      - Check if a move is possible and perform the move
	      - if so. Uses ?dx and ?dy to get the move direction and
	      - ?x and ?y for current position. If it can't move
	      - in some direction it will change direction.
	      -->
	    <event name="endmove">
	        <super />
		<!-- Check if there is a free block sideways. If so we have a random
		     chance of trying that direction -->
		<if eval="rand(5)>3">
		    <var name="t" value="?maze_main.maze[?x+?dy,?y+?dx]==' '" />
		    <if eval="?t">
		        <true>
		            <!-- Swap dx and dy to turn left or right -->
			    <var name="s" value="?dx" />
			    <var name="dx" value="?dy" />
			    <var name="dy" value="?s" />
		        </true>
			<false>
		    	    <var name="t" value="?maze_main.maze[?x-?dy,?y-?dx]==' '" />
			    <if eval="?t">
		                <!-- Swap dx and dy to turn left or right -->
			        <var name="s" value="-?dx" />
			        <var name="dx" value="-?dy" />
			        <var name="dy" value="?s" />
			    </if>
			</false>
		    </if>
		</if>
		<!-- If our current direction is free we proceed in that direction.
		     Else we try out a random new direction -->
		<if eval="?maze_main.maze[?x+?dx,?y+?dy]==' '">
		    <true>
		        <call event="startmove" />
		    </true>
		    <false>
			<var name="dxdy" value="int(rand(4.0))" />
			<call event="calcdxdy" />
			<call event="endmove" />
		    </false>
		</if>
	    </event>
	</script>

	<!-- *****************************************************
	  - This script controls the behaviour of a piece of fruit.
	  -  ***************************************************** -->
	<script name="fruit">
	    <superscript name="automovingobject" />

	    <!--
	      - Initialize a piece of fruit.
	      -->
	    <event name="init">
	    	<!-- Random start location -->
		<switch eval="int(rand(3))">
		    <case value="0">
			<var name="x" value="14" />
			<var name="y" value="14" />
		    </case>
		    <case value="1">
			<var name="x" value="1" />
			<var name="y" value="14" />
		    </case>
		    <case value="2">
			<var name="x" value="14" />
			<var name="y" value="1" />
		    </case>
		</switch>
		<var name="dim" value="?maze_main.blockdim" />
		<!-- Random fruit material -->
		<switch eval="int(rand(4))">
		    <case value="0"> <var name="material" value="banana" /> </case>
		    <case value="1"> <var name="material" value="pear" /> </case>
		    <case value="2"> <var name="material" value="apple" /> </case>
		    <case value="3"> <var name="material" value="mushroom" /> </case>
		</switch>
		<var name="speed" value="?maze_main.fruitspeed" />
		<super />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script controls the behaviour of a monster.
	  -  ***************************************************** -->
	<script name="monster">
	    <superscript name="automovingobject" />

	    <!--
	      - Initialize a monster.
	      -->
	    <event name="init">
		<var name="x" value="14" />
		<var name="y" value="14" />
		<var name="dim" value="?maze_main.blockdim" />
		<var name="material" value="monster" />
		<var name="speed" value="?maze_main.monsterspeed" />
		<super />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script controls the behaviour of our hero.
	  -  ***************************************************** -->
	<script name="maze_hero">
	    <superscript name="movingobject" />

	    <!--
	      - Initialize our hero.
	      -->
	    <event name="init">
		<var name="x" value="1" />
		<var name="y" value="1" />
		<var name="dim" value="?maze_main.blockdim" />
		<var name="material" value="hero" />
		<var name="speed" value="?maze_main.herospeed" />
		<super />
	        <createpropclass name="pckeyinput" />
		<default propclass="pc(pckeyinput)" />
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="right" />
		    <par id="parid(command)" value="right" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="left" />
		    <par id="parid(command)" value="left" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="up" />
		    <par id="parid(command)" value="up" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="down" />
		    <par id="parid(command)" value="down" />
		</action>
	    </event>

	    <!--
	      - Override from superscript so that we can check collision
	      - here.
	      -->
	    <event name="endmove">
	        <super />
		<for var="i" start="1" end="?maze_main.monstercnt">
		    <var name="pc" value="?maze_main.(bb_monster+?i)" />
		    <if eval="property(?pc,propid(visible))==true">
		        <if eval="bb_testcollide(?pc)">
			    <sound name="bloop" loop="false" />
			    <property propclass="?pc" id="propid(visible)" value="false" />
			</if>
		    </if>
		</for>
	    </event>

	    <!--
	      - Check if a move is possible and perform the move
	      - if so. Uses ?dx and ?dy to get the move direction and
	      - ?x and ?y for current position.
	      -->
	    <event name="checkmove">
	        <if eval="?moving">
		    <stop />
		</if>
		<if eval="?maze_main.maze[?x+?dx,?y+?dy]==' '">
		    <call event="startmove" />
		</if>
	    </event>

	    <!--
	      - Movement events.
	      -->
	    <event name="pckeyinput_right1">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_left1">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_down1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_up1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkmove" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a block in the maze game.
	  -  ***************************************************** -->
        <script name="maze_block">
	    <!--
	      - Initialize this block.
	      - It assumes ?maze_main.x and ?maze_main.y are set to the
	      - x,y index of the block.
	      - Also uses ?maze_main.blockdim.
	      -->
	    <event name="init">
	        <createpropclass name="pcbillboard" />
		<default propclass="pc(pcbillboard)" />
	        <property id="propid(name)" value="block" />
	        <property id="propid(materialname)" value="slanted_stone" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="false" />
	        <property id="propid(restack)" value="false" />
	        <property id="propid(width)" value="500+?maze_main.blockdim" />
	        <property id="propid(height)" value="500+?maze_main.blockdim" />
	        <property id="propid(x)" value="?maze_main.x*?maze_main.blockdim" />
	        <property id="propid(y)" value="?maze_main.y*?maze_main.blockdim" />
	    </event>
	</script>

	<!-- *****************************************************
	  -  *****************************************************
	  - This is the boulderdash game script.
	  -  *****************************************************
	  -  ***************************************************** -->
	<script name="bdash_main">
	    <superscript name="supergame" />

	    <event name="init">
	        <print value="BOULDERDASH"/>

	        <createpropclass name="pcinventory" />
	        <createpropclass name="pctimer" />

	    	<super />

		<!-- Set some defaults -->
		<var name="dimension" value="80" />
		<var name="blockdim" value="19200" />
		<var name="herospeed" value="0.07" />
		<var name="fallspeed" value="0.15" />
		<var name="pushspeed" value="0.12" />
		<var name="boardspeed" value="0.003" />

		<!-- Size of the visible area in blocks -->
		<var name="vis" value="307200/?blockdim" />

		<!-- Create the menu back button -->
		<createentity name="back_button" behaviour="back_button" />
		<var entity="back_button" name="game_entity" value="ent()" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="back_button" />

		<!-- Every entity we create will get a name made from a unique number -->
		<var name="entity_number" value="0" />

		<!-- A stack of explosions that need to be done -->
		<var name="explosion_stack" value="0" />

		<!-- All blocktypes -->
		<var name="blocktypes"
		  value="'. HH#W#B###R#*#+XXXxOOOoMdMaMbMm=L=U=1=2=3=4=a=b=c=d=+=*=&=|=^EcEtElEbErE1E2E3E4KRKGKBKY=R=G=B=YDRDGDBDYDO:L:U:1:2:3:4:#:%>R>L>U>D'" />

		<!-- A stack of freed entities to reuse (per type) -->
		<expr eval="inittable(table='entstack_',value=0)" />

		<!-- Create a table of materials per block type -->
		<var name="'material_. '" value="black" />
		<var name="'material_HH'" value="hero" />
		<var name="'material_#W'" value="wood_box" />
		<var name="'material_#B'" value="slanted_stone" />
		<var name="'material_##'" value="sand_stone" />
		<var name="'material_#R'" value="rock" />
		<var name="'material_#*'" value="brick_full" />
		<var name="'material_#+'" value="brick_broken" />
		<var name="'material_XX'" value="diamond" />
		<var name="'material_Xx'" value="diamond_bomb" />
		<var name="'material_OO'" value="bomb" />
		<var name="'material_Oo'" value="bomb" />
		<var name="'material_Md'" value="monster" />
		<var name="'material_Ma'" value="apple" />
		<var name="'material_Mb'" value="banana" />
		<var name="'material_Mm'" value="mushroom" />
		<var name="'material_:L'" value="fattube_lr" />
		<var name="'material_:U'" value="fattube_ud" />
		<var name="'material_:1'" value="fattube_lu" />
		<var name="'material_:2'" value="fattube_ld" />
		<var name="'material_:3'" value="fattube_ru" />
		<var name="'material_:4'" value="fattube_rd" />
		<var name="'material_:#'" value="fattube_lrud" />
		<var name="'material_:%'" value="fattube_udlr" />
		<var name="'material_=L'" value="tube_lr" />
		<var name="'material_=U'" value="tube_ud" />
		<var name="'material_=1'" value="tube_lu" />
		<var name="'material_=2'" value="tube_ld" />
		<var name="'material_=3'" value="tube_ru" />
		<var name="'material_=4'" value="tube_rd" />
		<var name="'material_=a'" value="tube_lrd" />
		<var name="'material_=b'" value="tube_lru" />
		<var name="'material_=c'" value="tube_lud" />
		<var name="'material_=d'" value="tube_rud" />
		<var name="'material_=+'" value="tube_lrud" />
		<var name="'material_=&'" value="tube_and" />
		<var name="'material_=|'" value="tube_or" />
		<var name="'material_=^'" value="tube_xor" />
		<var name="'material_=*'" value="tube_power" />
		<var name="'material_=R'" value="tube_redkey" />
		<var name="'material_=G'" value="tube_greenkey" />
		<var name="'material_=B'" value="tube_bluekey" />
		<var name="'material_=Y'" value="tube_yellowkey" />
		<var name="'material_Ec'" value="explosion_c" />
		<var name="'material_Et'" value="explosion_t" />
		<var name="'material_El'" value="explosion_l" />
		<var name="'material_Eb'" value="explosion_b" />
		<var name="'material_Er'" value="explosion_r" />
		<var name="'material_E1'" value="explosion_bl" />
		<var name="'material_E2'" value="explosion_br" />
		<var name="'material_E3'" value="explosion_tl" />
		<var name="'material_E4'" value="explosion_tr" />
		<var name="'material_KR'" value="redkey" />
		<var name="'material_KG'" value="greenkey" />
		<var name="'material_KB'" value="bluekey" />
		<var name="'material_KY'" value="yellowkey" />
		<var name="'material_DR'" value="doorred" />
		<var name="'material_DG'" value="doorgreen" />
		<var name="'material_DB'" value="doorblue" />
		<var name="'material_DY'" value="dooryellow" />
		<var name="'material_DO'" value="dooropen" />
		<var name="'material_>R'" value="arrow_r" />
		<var name="'material_>L'" value="arrow_l" />
		<var name="'material_>U'" value="arrow_u" />
		<var name="'material_>D'" value="arrow_d" />
		<!-- Create a table of behaviours per block type -->
		<expr eval="inittable(table='behaviour_',value='bdash_nonmovable')" />
		<var name="'behaviour_. '" value="''" />
		<var name="'behaviour_HH'" value="''" />
		<var name="'behaviour_#W'" value="bdash_pushable" />
		<var name="'behaviour_#R'" value="bdash_movable" />
		<var name="'behaviour_XX'" value="bdash_diamond" />
		<var name="'behaviour_Xx'" value="bdash_diamond_bomb" />
		<var name="'behaviour_OO'" value="bdash_bomb" />
		<var name="'behaviour_Oo'" value="bdash_timedbomb" />
		<var name="'behaviour_Md'" value="bdash_diamond_monster" />
		<var name="'behaviour_Ma'" value="bdash_apple_monster" />
		<var name="'behaviour_Mb'" value="bdash_apple_monster" />
		<var name="'behaviour_Mm'" value="bdash_mushroom_monster" />
		<var name="'behaviour_=L'" value="bdash_tube" />
		<var name="'behaviour_=U'" value="bdash_tube" />
		<var name="'behaviour_=1'" value="bdash_tube" />
		<var name="'behaviour_=2'" value="bdash_tube" />
		<var name="'behaviour_=3'" value="bdash_tube" />
		<var name="'behaviour_=4'" value="bdash_tube" />
		<var name="'behaviour_=a'" value="bdash_tube" />
		<var name="'behaviour_=b'" value="bdash_tube" />
		<var name="'behaviour_=c'" value="bdash_tube" />
		<var name="'behaviour_=d'" value="bdash_tube" />
		<var name="'behaviour_=+'" value="bdash_tube" />
		<var name="'behaviour_=&'" value="bdash_tube" />
		<var name="'behaviour_=|'" value="bdash_tube" />
		<var name="'behaviour_=^'" value="bdash_tube" />
		<var name="'behaviour_=*'" value="bdash_tube_power" />
		<var name="'behaviour_=R'" value="bdash_tube_key" />
		<var name="'behaviour_=G'" value="bdash_tube_key" />
		<var name="'behaviour_=B'" value="bdash_tube_key" />
		<var name="'behaviour_=Y'" value="bdash_tube_key" />
		<var name="'behaviour_Ec'" value="bdash_explosion" />
		<var name="'behaviour_Et'" value="bdash_explosion" />
		<var name="'behaviour_El'" value="bdash_explosion" />
		<var name="'behaviour_Eb'" value="bdash_explosion" />
		<var name="'behaviour_Er'" value="bdash_explosion" />
		<var name="'behaviour_E1'" value="bdash_explosion" />
		<var name="'behaviour_E2'" value="bdash_explosion" />
		<var name="'behaviour_E3'" value="bdash_explosion" />
		<var name="'behaviour_E4'" value="bdash_explosion" />
		<var name="'behaviour_DR'" value="bdash_door" />
		<var name="'behaviour_DG'" value="bdash_door" />
		<var name="'behaviour_DB'" value="bdash_door" />
		<var name="'behaviour_DY'" value="bdash_door" />

		<!-- For all fat tubes we have directional values (4 bits: LRUD) -->
		<var name="'fattube_:L'" value="12" />	<!-- LR.. -->
		<var name="'fattube_:U'" value="3" />	<!-- ..UD -->
		<var name="'fattube_:1'" value="10" />	<!-- L.U. -->
		<var name="'fattube_:2'" value="9" />	<!-- L..D -->
		<var name="'fattube_:3'" value="6" />	<!-- .RU. -->
		<var name="'fattube_:4'" value="5" />	<!-- .R.D -->
		<var name="'fattube_:#'" value="-1" />	<!-- LRUD -->
		<var name="'fattube_:%'" value="-1" />	<!-- LRUD -->

		<!-- For all tubes we have directional output values (4 bits: LRUD) -->
		<var name="'tubeout_=L'" value="12" />	<!-- LR.. -->
		<var name="'tubeout_=U'" value="3" />	<!-- ..UD -->
		<var name="'tubeout_=1'" value="10" />	<!-- L.U. -->
		<var name="'tubeout_=2'" value="9" />	<!-- L..D -->
		<var name="'tubeout_=3'" value="6" />	<!-- .RU. -->
		<var name="'tubeout_=4'" value="5" />	<!-- .R.D -->
		<var name="'tubeout_=a'" value="13" />	<!-- LR.D -->
		<var name="'tubeout_=b'" value="14" />	<!-- LRU. -->
		<var name="'tubeout_=c'" value="11" />	<!-- L.UD -->
		<var name="'tubeout_=d'" value="7" />	<!-- .RUD -->
		<var name="'tubeout_=+'" value="15" />	<!-- LRUD -->
		<var name="'tubeout_=&'" value="4" />	<!-- .R.. -->
		<var name="'tubeout_=|'" value="4" />	<!-- .R.. -->
		<var name="'tubeout_=^'" value="4" />	<!-- .R.. -->
		<var name="'tubeout_=*'" value="15" />	<!-- LRUD -->
		<var name="'tubeout_=R'" value="0" />	<!-- .... -->
		<var name="'tubeout_=G'" value="0" />	<!-- .... -->
		<var name="'tubeout_=B'" value="0" />	<!-- .... -->
		<var name="'tubeout_=Y'" value="0" />	<!-- .... -->
		<!-- For all tubes we have directional input values (4 bits: RLDU) -->
		<var name="'tubein_=L'" value="12" />	<!-- RL.. -->
		<var name="'tubein_=U'" value="3" />	<!-- ..DU -->
		<var name="'tubein_=1'" value="5" />	<!-- .L.U -->
		<var name="'tubein_=2'" value="6" />	<!-- .LD. -->
		<var name="'tubein_=3'" value="9" />	<!-- R..U -->
		<var name="'tubein_=4'" value="10" />	<!-- R.D. -->
		<var name="'tubein_=a'" value="14" />	<!-- RLD. -->
		<var name="'tubein_=b'" value="13" />	<!-- RL.U -->
		<var name="'tubein_=c'" value="7" />	<!-- .LDU -->
		<var name="'tubein_=d'" value="11" />	<!-- R.DU -->
		<var name="'tubein_=+'" value="15" />	<!-- RLDU -->
		<var name="'tubein_=&'" value="7" />	<!-- .LDU -->
		<var name="'tubein_=|'" value="7" />	<!-- .LDU -->
		<var name="'tubein_=^'" value="7" />	<!-- .LDU -->
		<var name="'tubein_=*'" value="15" />	<!-- RLDU -->
		<var name="'tubein_=R'" value="15" />	<!-- RLDU -->
		<var name="'tubein_=G'" value="15" />	<!-- RLDU -->
		<var name="'tubein_=B'" value="15" />	<!-- RLDU -->
		<var name="'tubein_=Y'" value="15" />	<!-- RLDU -->

		<!-- Create a table of 'falldown' settings per block type -->
		<expr eval="inittable(table='falldown_',value=false)" />
		<var name="'falldown_#R'" value="true" />
		<var name="'falldown_XX'" value="true" />
		<var name="'falldown_Xx'" value="true" />
		<var name="'falldown_OO'" value="true" />
		<var name="'falldown_Oo'" value="true" />

		<!-- Create a table of 'falloff' settings per block type -->
		<expr eval="inittable(table='falloff_',value=false)" />
		<var name="'falloff_#B'" value="true" />
		<var name="'falloff_#R'" value="true" />
		<var name="'falloff_XX'" value="true" />
		<var name="'falloff_Xx'" value="true" />
		<var name="'falloff_OO'" value="true" />
		<var name="'falloff_Oo'" value="true" />
		<var name="'falloff_Ma'" value="true" />
		<var name="'falloff_Mb'" value="true" />
		<var name="'falloff_Mm'" value="true" />

		<!--
		  - Create a table of 'destroy' settings per block type.
		  - Three possible values:
		  -	- '0': can't be destroyed by explosion.
		  -	- '1': can be destroyed by explosion.
		  -	- '2': will cause an explosion if destroyed.
		  -	- '3': will degrate to another blocktype (uses 'blockchange_' table).
		  -->
		<expr eval="inittable(table='destroy_',value=1)" />
		<var name="'destroy_#B'" value="0" />
		<var name="'destroy_#*'" value="3" />
		<var name="'destroy_OO'" value="2" />
		<var name="'destroy_Oo'" value="2" />
		<var name="'destroy_=*'" value="2" />
		<var name="'destroy_DR'" value="0" />
		<var name="'destroy_DG'" value="0" />
		<var name="'destroy_DB'" value="0" />
		<var name="'destroy_DY'" value="0" />
		<var name="'destroy_DO'" value="0" />
		<var name="'destroy_=R'" value="0" />
		<var name="'destroy_=G'" value="0" />
		<var name="'destroy_=B'" value="0" />
		<var name="'destroy_=Y'" value="0" />
		<var name="'destroy_:L'" value="0" />
		<var name="'destroy_:U'" value="0" />
		<var name="'destroy_:1'" value="0" />
		<var name="'destroy_:2'" value="0" />
		<var name="'destroy_:3'" value="0" />
		<var name="'destroy_:4'" value="0" />
		<var name="'destroy_:#'" value="0" />
		<var name="'destroy_:%'" value="0" />
		<var name="'destroy_>R'" value="0" />
		<var name="'destroy_>L'" value="0" />
		<var name="'destroy_>U'" value="0" />
		<var name="'destroy_>D'" value="0" />

		<!--
		  - Create a table of 'destroy_diamond' settings per block type.
		  - Three possible values:
		  -	- '0': can't be replaced by diamond on a diamond explosion.
		  -	- '1': can be replaced by diamond.
		  -->
		<expr eval="inittable(table='destroy_diamond_',value=0)" />
		<var name="'destroy_diamond_. '" value="1" />
		<var name="'destroy_diamond_##'" value="1" />
		<var name="'destroy_diamond_#R'" value="1" />
		<var name="'destroy_diamond_Xx'" value="1" />
		<var name="'destroy_diamond_Md'" value="1" />

		<!--
		  - For all blocktypes where 'destroy_' == 3 we have a table
		  - of what to change this block too when destroyed.
		  -->
		<var name="'blockchange_#*'" value="'#+'" />

		<!--
		  - Create a table of 'rotate' settings per block type
		  - Value is '' if rotate is not possible. Otherwise the blocktype.
		  -->
		<expr eval="inittable(table='rotate_',value='')" />
		<var name="'rotate_=L'" value="'=U'" />
		<var name="'rotate_=U'" value="'=L'" />
		<var name="'rotate_=1'" value="'=3'" />
		<var name="'rotate_=2'" value="'=1'" />
		<var name="'rotate_=3'" value="'=4'" />
		<var name="'rotate_=4'" value="'=2'" />
		<var name="'rotate_=a'" value="'=c'" />
		<var name="'rotate_=b'" value="'=d'" />
		<var name="'rotate_=c'" value="'=b'" />
		<var name="'rotate_=d'" value="'=a'" />

		<!--
		  - Create a table of 'explode' settings per block type.
		  - Two possible values:
		  -	- '0': object doesn't explode when something drops on it.
		  -	- '1': object explodes.
		  -	- '2': object explodes with diamonds.
		  -->
		<expr eval="inittable(table='explode_',value=0)" />
		<var name="'explode_Xx'" value="2" />
		<var name="'explode_OO'" value="1" />
		<var name="'explode_Md'" value="2" />

		<!--
		  - If some color is 0 we don't have the key and all doors of that
		  - color are closed. If the value > 0 the doors are open.
		  -->
		<var name="havekeyR" value="0" />
		<var name="havekeyG" value="0" />
		<var name="havekeyB" value="0" />
		<var name="havekeyY" value="0" />
		<var name="closedoor_stackR" value="0" />
		<var name="closedoor_stackG" value="0" />
		<var name="closedoor_stackB" value="0" />
		<var name="closedoor_stackY" value="0" />
		<var name="opendoor_stackR" value="0" />
		<var name="opendoor_stackG" value="0" />
		<var name="opendoor_stackB" value="0" />
		<var name="opendoor_stackY" value="0" />

		<!--  Create the maze -->
		<if eval="readfile(row,'/cellib/objects/maze.txt') == -1">
		    <reporterror message="'Cannot open maze.txt!'" />
		</if>
		<for var="y" start="0" end="?dimension-1">
		    <var name="row" value="?(row+?y)" />
		    <for var="x" start="0" end="?dimension-1">
		        <var name="blocktype" value="strsub(?row,?x+?x,2)" />
		        <call event="initblock" />
		    </for>
		</for>

		<!-- Current position of game layer -->
		<var name="layer_movetox" value="(?vis/2-?hero_start_x)*?bdash_main.blockdim" />
		<var name="layer_movetoy" value="(?vis/2-?hero_start_y)*?bdash_main.blockdim" />
		<var name="layer_x" value="?layer_movetox" />
		<var name="layer_y" value="?layer_movetoy" />
		<bb_movelayer layer="game" x="?layer_x" y="?layer_y" />
		<action propclass="pc(pctimer)" id="propid(WakeUpFrame)" />

		<!-- Counter to avoid doing too much work every frame -->
		<var name="counter" value="10" />
	    </event>

	    <!--
	      - Routine to initialize a table for blocktypes to some default value.
	      - Parameters:
	      -    @table is the table name
	      -    @value is the default value
	      -->
	    <event name="inittable">
	        <lvar name="l" value="strlen(?blocktypes)" />
		<for var="i" start="0" end="#l/2-1">
		    <lvar name="bt" value="strsub(?blocktypes,?i+?i,2)" />
		    <var name="@table+#bt" value="@value" />
		</for>
	    </event>

	    <!--
	      - Create an entity with a given type. Possibly fetch it from the
	      - free entity stack. Parameter is @blocktype. Returns the entity.
	      -->
	    <event name="createentity">
	    	<lvar name="sn" value="entstack_+@blocktype" />
	        <if eval="?#sn > 0">
		    <lvar name="ent" value="?(#sn+?#sn)" />
		    <property propclass="?(#ent).pcbb" id="propid(visible)" value="true" />
		    <call entity="#ent" event="reinit" />
		    <var name="#sn" value="?(#sn)-1" />
		    <return value="#ent" />
		</if>
		<lvar name="entname" value="?entity_number" />
		<var name="entity_number" value="?entity_number+1" />
		<createentity name="#entname" behaviour="?behaviour[@blocktype]" />
		<inventory propclass="pc(pcinventory)" />
		<lvar name="ent" value="ent(#entname)" />
		<inventory_add child="#ent" />
		<return value="#ent" />
	    </event>

	    <!--
	      - Destroy an entity (put it back on the stack).
	      - Parameter is @entity.
	      -->
	    <event name="destroyentity">
		<call entity="@entity" event="cleanup" />
	    	<lvar name="blocktype" value="?(@entity).blocktype" />
		<property propclass="?(@entity).pcbb" id="propid(visible)" value="false" />
	    	<lvar name="sn" value="entstack_+#blocktype" />
		<var name="#sn" value="?(#sn)+1" />
		<var name="#sn+?#sn" value="@entity" />
	    </event>

	    <!--
	      - Initialize one block. This will create the entity representing
	      - the block and it will set it at the right position on the puzzle
	      - board.
	      - This event uses ?x and ?y which should be set outside this routine.
	      - This event also uses ?blocktype and the ?material_ and ?behaviour_ arrays.
	      - This event will correctly handle the special 'HH' block type (for hero)
	      - and set the hero start location (?hero_start_x and ?hero_start_y)
	      - and the ?hero entity variable.
	      -->
	    <event name="initblock">
	        <lvar name="mazepos" value="maze_+?x+'_'+?y" />
	    	<if eval="?blocktype == 'HH'">
		    <var name="hero_start_x" value="?x" />
		    <var name="hero_start_y" value="?y" />
		    <var name="hero_x" value="?x" />
		    <var name="hero_y" value="?y" />
		    <createentity name="hero" behaviour="bdash_hero" />
		    <inventory propclass="pc(pcinventory)" />
		    <var name="hero" value="ent(hero)" />
		    <inventory_add child="?hero" />
		    <var name="#mazepos" value="''" />
		    <stop />
		</if>
	    	<if eval="?blocktype != '. '">
		    <var name="#mazepos" value="createentity(blocktype=?blocktype)" />
		    <stop />
	    	</if>
		<var name="#mazepos" value="''" />
	    </event>

	    <!--
	      - Routine used by the checkmove events in the bdash_hero
	      - script to clear a block. This routine does not do the
	      - falling object test because it is supposed to be used when
	      - the hero will move to the cleared block.
	      - Note that this routine will properly take care of falling
	      - objects.
	      - Uses @x and @y parameters.
	      -->
	    <event name="clearblock_nocheck">
		<lvar name="ent" value="?maze[@x,@y]" />
		<if eval="#ent==''"> <stop /> </if>
		<if eval="?(#ent).moving">
		    <!-- Block is moving -->
		    <lvar name="oldx" value="?(#ent).oldx" />
		    <lvar name="oldy" value="?(#ent).oldy" />
		    <if eval="#oldx==@x && #oldy==@y">
		        <lvar name="oldx" value="?(#ent).x" />
		        <lvar name="oldy" value="?(#ent).y" />
		    </if>
		    <var name="maze_+#oldx+'_'+#oldy" value="''" />
		    <!-- We have to check the old block -->
		    <call event="ifempty_checkfall">
		    	<par id="parid(x)" value="#oldx" />
		    	<par id="parid(y)" value="#oldy" />
		    </call>
		</if>
		<expr eval="destroyentity(entity=#ent)" />
		<var name="maze_+@x+'_'+@y" value="''" />
	    </event>

	    <!--
	      - Clear a block and check if objects will fall down.
	      - Uses @x and @y parameters.
	      -->
	    <event name="clearblock_check">
	    	<call event="clearblock_nocheck"> <inherit /> </call>
		<call event="ifempty_checkfall"> <inherit /> </call>
	    </event>

	    <!--
	      - Routine to create a block. Similar to initblock but uses
	      - parameters @x, @y, and @blocktype.
	      -->
	    <event name="createblock">
	    	<var name="x" value="@x" />
	    	<var name="y" value="@y" />
	    	<var name="blocktype" value="@blocktype" />
		<call event="initblock" />
	    </event>

	    <!--
	      - Routine used by the checkmove events in the bdash_hero
	      - script to set a block. Uses @x and @y for the position
	      - of the block and @blocktype for the block letter.
	      - It also uses @entity to set the entity at the block.
	      - Uses parameters @entity, @blocktype, @x, and @y.
	      -->
	    <event name="setblock">
		<var name="maze_+@x+'_'+@y" value="@entity" />
		<if eval="@blocktype == '. '">
		    <call event="checkfall"> <inherit /> </call>
	    	</if>
	    </event>

	    <!--
	      - Start movement of a block in @dx,@dy direction.
	      - direction. Other parameters: @entity.
	      -->
	    <event name="startmove_block">
	    	<lvar name="x" value="?(@entity).x" />
	    	<lvar name="y" value="?(@entity).y" />
	    	<var entity="@entity" name="oldx" value="#x" />
	    	<var entity="@entity" name="oldy" value="#y" />
		<call event="setblock">
		    <par id="parid(entity)" value="@entity" />
		    <par id="parid(blocktype)" value="?(@entity).blocktype" />
		    <par id="parid(x)" value="#x+@dx" />
		    <par id="parid(y)" value="#y+@dy" />
		</call>
	    </event>

	    <!--
	      - End movement of a block.
	      - direction. Parameter: @entity.
	      -->
	    <event name="endmove_block">
	    	<lvar name="x" value="?(@entity).x" />
	    	<lvar name="y" value="?(@entity).y" />
		<call event="setblock">
		    <par id="parid(entity)" value="''" />
		    <par id="parid(blocktype)" value="'. '" />
		    <par id="parid(x)" value="?(@entity).oldx" />
		    <par id="parid(y)" value="?(@entity).oldy" />
		</call>
		<call event="ifempty_checkfall">
		    <par id="parid(x)" value="#x" />
		    <par id="parid(y)" value="#y+1" />
		</call>
	    </event>

	    <!--
	      - Get the entity at some position. This uses both the maze information
	      - as the position of the hero. Use @x and @y parameters.
	      - Returns entity (can be hero too) or ''.
	      -->
	    <event name="get_entity">
		<lvar name="ent" value="?maze[@x,@y]" />
		<if eval="#ent">
		    <return value="#ent" />
		</if>
		<if eval="(?hero_x == @x) && (?hero_y == @y)">
		    <return value="?hero" />
	        </if>
		<return value="''" />
	    </event>

	    <!--
	      - Get the block type at some position. Parameters are @x
	      - and @y.
	      -->
	    <event name="get_blocktype">
	        <lvar name="ent" value="get_entity(...)" />
		<if eval="!#ent">
		    <return value="'. '" />
	        </if>
		<return value="?(#ent).blocktype" />
	    </event>

	    <!--
	      - Get the falloff property for a given block. In case the
	      - block is moving this will always return false.
	      - Parameters are @x and @y.
	      -->
	    <event name="get_falloff">
	        <lvar name="ent" value="get_entity(...)" />
		<if eval="!#ent">
		    <return value="false" />
	        </if>
		<if eval="?(#ent).moving">
		    <return value="false" />
		</if>
		<return value="?falloff[?(#ent).blocktype]" />
	    </event>

	    <!--
	      - Check if the block above ?x,?y can fall down and if so
	      - make sure it will fall down. It will also check if
	      - blocks left or right of ?x,?y are on a 'falloff' block
	      - and in that case it will also let those drop.
	      - Note: this routine will use 'falldown' event in the
	      - behaviour of the block. It expects that 'falldown' event
	      - to set the 'fallen' variable to true if it really starts
	      - falling down.
	      - Uses parameters @x and @y.
	      -->
	    <event name="checkfall">
	    	<!-- First check if the block above us can fall down -->
		<lvar name="ent" value="?maze[@x,@y-1]" />
		<if eval="#ent">
		    <true>
		    	<if eval="?falldown[?#ent.blocktype]">
		            <if eval="(#ent)::falldown(dx=0,dy=1)"> <stop /> </if>
			</if>
		    </true>
		    <false>
		        <!-- Then we check if the block at -1,-1 from us can fall down -->
		        <lvar name="ent" value="?maze[@x-1,@y-1]" />
		        <if eval="#ent">
		            <if eval="get_falloff(x=@x-1,y=@y)">
				<if eval="?falldown[?#ent.blocktype]">
			    	    <if eval="(#ent)::falldown(dx=1,dy=1)"> <stop /> </if>
			        </if>
		            </if>
		        </if>
		        <lvar name="ent" value="?maze[@x+1,@y-1]" />
		        <if eval="#ent">
		            <if eval="get_falloff(x=@x+1,y=@y)">
				<if eval="?falldown[?#ent.blocktype]">
			    	    <if eval="(#ent)::falldown(dx=-1,dy=1)"> <stop /> </if>
			        </if>
		            </if>
		        </if>
		    </false>
		</if>
		<lvar name="ent" value="get_entity(x=@x,y=@y+1)" />
		<if eval="!#ent">
		    <lvar name="ent" value="?maze[@x-1,@y]" />
		    <if eval="#ent">
		        <if eval="get_falloff(x=@x-1,y=@y+1)">
			    <if eval="?falldown[?#ent.blocktype]">
			        <if eval="(#ent)::falldown(dx=1,dy=1)"> <stop /> </if>
			    </if>
		        </if>
		    </if>
		    <lvar name="ent" value="?maze[@x+1,@y]" />
		    <if eval="#ent">
		        <if eval="get_falloff(x=@x+1,y=@y+1)">
			    <if eval="?falldown[?#ent.blocktype]">
			        <if eval="(#ent)::falldown(dx=-1,dy=1)"> <stop /> </if>
			    </if>
		        </if>
		    </if>
	    	</if>
	    </event>

	    <!--
	      - Same as checkfall but also makes sure the block
	      - at @x,@y is really empty. If the block at @x,@y
	      - has 'falloff' property then we also proceed.
	      - Uses parameters @x and @y.
	      -->
	    <event name="ifempty_checkfall">
		<if eval="!get_entity(...)">
		    <expr eval="checkfall(...)" />
	    	</if>
	    	<lvar name="x" value="@x" />
	    	<lvar name="y" value="@y" />
		<if eval="!get_entity(x=#x-1,y=#y)">
		    <expr eval="checkfall(x=#x-1,y=#y)" />
	    	</if>
		<if eval="!get_entity(x=#x+1,y=#y)">
		    <expr eval="checkfall(x=#x+1,y=#y)" />
	    	</if>
	    </event>

	    <!--
	      - Check if a given block can fall down or sideways.
	      - Parameters are @x and @y.
	      -->
	    <event name="checkfall_block">
		<call event="ifempty_checkfall">
		    <par id="parid(x)" value="@x" />
		    <par id="parid(y)" value="@y+1" />
		</call>
	    </event>

	    <!--
	      - Handle the explosion of a single block.
	      - Parameters: @x, @y, and @blocktype.
	      -->
	    <event name="diamond_explodeblock">
		<lvar name="destroy" value="?('destroy_diamond_'+get_blocktype(...))" />
		<if eval="#destroy==1">
		    <call event="clearblock_nocheck"> <inherit /> </call>
		    <call event="createblock"> <inherit /> </call>
		    <call event="checkfall_block"> <inherit /> </call>
		</if>
	    </event>

	    <!--
	      - Fire a diamond explosion. Parameters are @x and @y.
	      -->
	    <event name="diamond_bang">
		<sound name="clang" loop="false" />

		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x-1" />
			<par id="parid(y)" value="@y" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x+1" />
			<par id="parid(y)" value="@y" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x-1" />
			<par id="parid(y)" value="@y-1" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x+1" />
			<par id="parid(y)" value="@y-1" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x-1" />
			<par id="parid(y)" value="@y+1" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x+1" />
			<par id="parid(y)" value="@y+1" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y+1" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y-1" />
		</call>
		<call event="diamond_explodeblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y" />
		</call>
		<!--
		<call event="clearblock_nocheck"> <inherit /> </call>
		<call event="createblock">
			<par id="parid(blocktype)" value="'XX'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y" />
		</call>
		-->
		<stop />
	    </event>

	    <!--
	      - Handle the explosion of a single block.
	      - Parameters: @x, @y, and @blocktype.
	      -->
	    <event name="explodeblock">
	    	<lvar name="bt" value="get_blocktype(...)" />
		<lvar name="destroy" value="?('destroy_'+#bt)" />
		<if eval="#destroy!=0">
		    <if eval="#bt=='HH'">
		    	<call event="addscore">
			    <par id="parid(score)" value="-20" />
			</call>
		    </if>
		    <call event="clearblock_nocheck"> <inherit /> </call>
		    <if eval="#destroy==3">
		        <call event="createblock">
			    <par id="parid(x)" value="@x" />
			    <par id="parid(y)" value="@y" />
			    <par id="parid(blocktype)" value="?('blockchange_'+#bt)" />
			</call>
			<stop />
		    </if>
		    <call event="createblock"> <inherit /> </call>
		    <if eval="#destroy==2">
			<call entity="?maze[@x,@y]" event="explode_later" />
		    </if>
		</if>
	    </event>

	    <!--
	      - Fire an explosion. Parameters are @x and @y.
	      -->
	    <event name="bang">
		<sound name="explosion" loop="false" />

		<call event="explodeblock">
			<par id="parid(blocktype)" value="'El'" />
			<par id="parid(x)" value="@x-1" />
			<par id="parid(y)" value="@y" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'Er'" />
			<par id="parid(x)" value="@x+1" />
			<par id="parid(y)" value="@y" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'E3'" />
			<par id="parid(x)" value="@x-1" />
			<par id="parid(y)" value="@y-1" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'E4'" />
			<par id="parid(x)" value="@x+1" />
			<par id="parid(y)" value="@y-1" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'E1'" />
			<par id="parid(x)" value="@x-1" />
			<par id="parid(y)" value="@y+1" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'E2'" />
			<par id="parid(x)" value="@x+1" />
			<par id="parid(y)" value="@y+1" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'Eb'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y+1" />
		</call>
		<call event="explodeblock">
			<par id="parid(blocktype)" value="'Et'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y-1" />
		</call>
	    	<lvar name="bt" value="get_blocktype(...)" />
		<lvar name="destroy" value="?('destroy_'+#bt)" />
		<if eval="#destroy!=0">
		    <call event="clearblock_nocheck"> <inherit /> </call>
		    <call event="createblock">
			<par id="parid(blocktype)" value="'Ec'" />
			<par id="parid(x)" value="@x" />
			<par id="parid(y)" value="@y" />
		    </call>
		</if>
		<stop />
	    </event>

	    <!--
	      - Push a new explosion on the stack.
	      - Parameters are @x and @y.
	      -->
	    <event name="new_explosion">
	        <var name="explosion_stack_x_+?explosion_stack" value="@x" />
	        <var name="explosion_stack_y_+?explosion_stack" value="@y" />
	        <var name="explosion_stack_event_+?explosion_stack" value="bang" />
		<var name="explosion_stack" value="?explosion_stack+1" />
	    </event>

	    <!--
	      - Push a new diamond explosion on the stack.
	      - Parameters are @x and @y.
	      -->
	    <event name="new_diamond_explosion">
	        <var name="explosion_stack_x_+?explosion_stack" value="@x" />
	        <var name="explosion_stack_y_+?explosion_stack" value="@y" />
	        <var name="explosion_stack_event_+?explosion_stack" value="diamond_bang" />
		<var name="explosion_stack" value="?explosion_stack+1" />
	    </event>


	    <!--
	      - Handle all explosions on the stack.
	      -->
	    <event name="fire_explosions">
		<for var="i" start="0" end="?explosion_stack-1">
		    <lvar name="x" value="?explosion_stack_x[?i]" />
		    <lvar name="y" value="?explosion_stack_y[?i]" />
		    <lvar name="event" value="?explosion_stack_event[?i]" />
		    <call event="#event">
		    	<par id="parid(x)" value="#x" />
		    	<par id="parid(y)" value="#y" />
		    </call>
		</for>
		<var name="explosion_stack" value="0" />
	    </event>

	    <!--
	      - Check if doors need opening.
	      - Parameter is @color
	      -->
	    <event name="check_doors">
		<if eval="!?(havekey+@color)">
	    	    <lvar name="ds" value="opendoor_stack+@color" />
	    	    <if eval="?#ds > 0">
		        <for var="i" start="0" end="?#ds-1">
			    <lvar name="ent" value="?(#ds+?i)" />
			    <lvar name="x" value="?#ent.x" />
			    <lvar name="y" value="?#ent.y" />
			    <call event="clearblock_nocheck">
			        <par id="parid(x)" value="#x" />
			        <par id="parid(y)" value="#y" />
			    </call>
			    <call event="createblock">
			        <par id="parid(blocktype)" value="'D'+@color" />
			        <par id="parid(x)" value="#x" />
			        <par id="parid(y)" value="#y" />
			    </call>
			    <lvar name="cds" value="closedoor_stack+@color" />
			    <var entity="bdash_main" name="#cds+?#cds" value="?maze[#x,#y]" />
			    <var entity="bdash_main" name="#cds" value="?#cds+1" />
		        </for>
		        <var name="#ds" value="0" />
		    </if>
		    <stop />
		</if>
	    	<lvar name="ds" value="closedoor_stack+@color" />
	    	<if eval="?#ds > 0">
		    <for var="i" start="0" end="?#ds-1">
			<lvar name="ent" value="?(#ds+?i)" />
			<lvar name="x" value="?#ent.x" />
			<lvar name="y" value="?#ent.y" />
			<call event="clearblock_nocheck">
			    <par id="parid(x)" value="#x" />
			    <par id="parid(y)" value="#y" />
			</call>
			<call event="createblock">
			    <par id="parid(blocktype)" value="'DO'" />
			    <par id="parid(x)" value="#x" />
			    <par id="parid(y)" value="#y" />
			</call>
			<lvar name="cds" value="opendoor_stack+@color" />
			<var entity="bdash_main" name="#cds+?#cds" value="?maze[#x,#y]" />
			<var entity="bdash_main" name="#cds" value="?#cds+1" />
		    </for>
		    <var name="#ds" value="0" />
		</if>
	    </event>

	    <!--
	      - Move the board slowly so the hero is centered.
	      -->
	    <event name="pctimer_wakeupframe">
		<lvar name="delta" value="?boardspeed*@elapsedticks" />
		<var name="layer_x" value="intpol(#delta,?layer_x,?layer_movetox)" />
		<var name="layer_y" value="intpol(#delta,?layer_y,?layer_movetoy)" />
		<bb_movelayer layer="game" x="?layer_x" y="?layer_y" />
		<call event="fire_explosions" />
		<if eval="?counter <= 0">
		    <var name="counter" value="50" />
		    <expr eval="check_doors(color='R')" />
		    <expr eval="check_doors(color='G')" />
		    <expr eval="check_doors(color='B')" />
		    <expr eval="check_doors(color='Y')" />
		    <stop />
	        </if>
		<var name="counter" value="?counter-1" />
	    </event>

	</script>

	<!--
	  - All scripts below (for blocks and hero) have the following common
	  - events:
	  -	- falldown: Called on the object when it could potentially fall down.
	  -	  Uses @dx and @dy parameters. Returns true if object really falls.
	  -->

	<!-- *****************************************************
	  - This script controls the behaviour of our hero.
	  -  ***************************************************** -->
	<script name="bdash_hero">
	    <superscript name="movingobject" />

	    <!--
	      - Initialize our hero.
	      - Uses ?bdash_main.hero_start_x and ?bdash_main.hero_start_y for
	      - the hero start location.
	      -->
	    <event name="init">
		<var name="x" value="?bdash_main.hero_start_x" />
		<var name="y" value="?bdash_main.hero_start_y" />
		<var name="dim" value="?bdash_main.blockdim" />
		<var name="material" value="hero" />
		<var name="speed" value="?bdash_main.herospeed" />
		<var name="power" value="0" />
		<var name="fattube_moving" value="false" />
		<super />
	        <var name="blocktype" value="'HH'" />
		<default propclass="?pcbb" />
	        <property id="propid(layer)" value="game" />
	        <createpropclass name="pckeyinput" />
		<default propclass="pc(pckeyinput)" />
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="right" />
		    <par id="parid(command)" value="move_right" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="left" />
		    <par id="parid(command)" value="move_left" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="up" />
		    <par id="parid(command)" value="move_up" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="down" />
		    <par id="parid(command)" value="move_down" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-right'" />
		    <par id="parid(command)" value="take_right" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-left'" />
		    <par id="parid(command)" value="take_left" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-up'" />
		    <par id="parid(command)" value="take_up" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-down'" />
		    <par id="parid(command)" value="take_down" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'ctrl-right'" />
		    <par id="parid(command)" value="rot_right" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'ctrl-left'" />
		    <par id="parid(command)" value="rot_left" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'ctrl-up'" />
		    <par id="parid(command)" value="rot_up" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'ctrl-down'" />
		    <par id="parid(command)" value="rot_down" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="space" />
		    <par id="parid(command)" value="bomb" />
		</action>
	    </event>

	    <!--
	      - Routine used by the checktake events below to clear a block.
	      - Uses ?newx, and ?newy for the position of the block to clear.
	      -->
	    <event name="clearblock_check">
		<call entity="bdash_main" event="clearblock_check">
		    <par id="parid(x)" value="?newx" />
		    <par id="parid(y)" value="?newy" />
		</call>
	    </event>

	    <!--
	      - Routine used by the checkmove events below to clear a block.
	      - This version does not force a falling object check because
	      - it is supposed to be used when the player moves to the clear
	      - block.
	      - Uses ?newx, and ?newy for the position of the block to clear.
	      -->
	    <event name="clearblock_nocheck">
		<call entity="bdash_main" event="clearblock_nocheck">
		    <par id="parid(x)" value="?newx" />
		    <par id="parid(y)" value="?newy" />
		</call>
	    </event>

	    <!--
	      - Find a suitable fattube exit.
	      -->
	    <event name="find_fattube_move">
	        <switch eval="?fattube_nextmask">
		    <case value="-1"> <lvar name="dx" value="?dx" /> <lvar name="dy" value="?dy" /> </case>
		    <case value="1"> <lvar name="dx" value="0" /> <lvar name="dy" value="1" /> </case>
		    <case value="2"> <lvar name="dx" value="0" /> <lvar name="dy" value="-1" /> </case>
		    <case value="4"> <lvar name="dx" value="1" /> <lvar name="dy" value="0" /> </case>
		    <case value="8"> <lvar name="dx" value="-1" /> <lvar name="dy" value="0" /> </case>
		</switch>
	        <lvar name="newx" value="?x+#dx" />
	        <lvar name="newy" value="?y+#dy" />
		<lvar name="bt" value="bdash_main::get_blocktype(x=#newx,y=#newy)" />
		<if eval="strsub(#bt,0,1)==':'">
		    <default propclass="?pcbb" />
	            <property id="propid(visible)" value="false" />
		    <call event="start_fattube_move">
		        <par id="parid(dx)" value="#dx" />
		        <par id="parid(dy)" value="#dy" />
		    </call>
		    <stop />
		</if>
		<!--
		  - We come out of the fattube. We check if we can really get out.
		  - If not we have to revert direction.
		  -->
		<var name="dx" value="#dx" />
		<var name="dy" value="#dy" />
		<var name="fattube_moving" value="false" />
		<call event="checkmove" />
		<!-- If we are moving then we got out and we can make ourselves visible again -->
		<if eval="?moving">
		    <default propclass="?pcbb" />
	            <property id="propid(visible)" value="true" />
		    <bb_tofront />
	    	</if>
	    </event>

	    <!--
	      - Check if we can move through a fat tube and
	      - start the move if possible.
	      - Parameters are @dx and @dy.
	      -->
	    <event name="start_fattube_move">
	        <lvar name="newx" value="?x+@dx" />
	        <lvar name="newy" value="?y+@dy" />
	    	<lvar name="mask" value="?bdash_main.fattube[bdash_main::get_blocktype(x=#newx,y=#newy)]" />
		<if eval="#mask==-1">
		    <!-- Special case: double tube -->
		    <var name="fattube_nextmask" value="-1" />
		    <var name="fattube_moving" value="true" />
		    <var name="dx" value="@dx" />
		    <var name="dy" value="@dy" />
		    <call event="startmove" />
		    <bb_toback />
		    <stop />
		</if>
		<if eval="!@dx">
		    <true>
		        <if eval="@dy==1">
		    	    <true> <lvar name="movemask" value="2" /> </true>
		    	    <false> <lvar name="movemask" value="1" /> </false>
		        </if>
		    </true>
		    <false>
		        <if eval="@dx==1">
		    	    <true> <lvar name="movemask" value="8" /> </true>
		    	    <false> <lvar name="movemask" value="4" /> </false>
		        </if>
		    </false>
		</if>
		<if eval="#mask & #movemask">
		    <var name="fattube_nextmask" value="#mask & ~#movemask" />
		    <var name="fattube_moving" value="true" />
		    <var name="dx" value="@dx" />
		    <var name="dy" value="@dy" />
		    <call event="startmove" />
		    <bb_toback />
		</if>
	    </event>

	    <!--
	      - Start moving the hero. This will set the block at
	      - ?x+?dx,?y+?dy to 'HH'.
	      -->
	    <event name="startmove">
	        <var name="oldx" value="?x" />
	        <var name="oldy" value="?y" />
	        <super />
		<var entity="bdash_main" name="hero_x" value="?x" />
		<var entity="bdash_main" name="hero_y" value="?y" />
	    </event>

	    <!--
	      - Our hero has stopped moving. This is called by the superscript
	      - and we use this to clear the block where the hero started from.
	      -->
	    <event name="endmove">
	    	<super />
		<var entity="bdash_main" name="layer_movetox"
			value="(?bdash_main.vis/2-?x)*?bdash_main.blockdim" />
		<var entity="bdash_main" name="layer_movetoy"
			value="(?bdash_main.vis/2-?y)*?bdash_main.blockdim" />
		<call entity="bdash_main" event="ifempty_checkfall">
		    <par id="parid(x)" value="?oldx" />
		    <par id="parid(y)" value="?oldy" />
	    	</call>
		<if eval="?fattube_moving">
		    <call event="find_fattube_move" />
		</if>
	    </event>

	    <!--
	      - Perform a push if possible.
	      -->
	    <event name="trypush">
		<if eval="bdash_main::get_entity(x=?newx+?dx,y=?newy+?dy) == ''">
		    <lvar name="ent" value="bdash_main::get_entity(x=?newx,y=?newy)" />
		    <if eval="!?(#ent).moving">
			<var entity="#ent" name="dx" value="?dx" />
			<var entity="#ent" name="dy" value="?dy" />
			<call entity="#ent" event="startmove" />
			<call event="startmove" />
		    </if>
		</if>
	    </event>

	    <!--
	      - Perform a push if possible.
	      - Only horizontal allowed.
	      -->
	    <event name="trypush_horizontal">
	    	<if eval="?dy==0">
		    <if eval="bdash_main::get_entity(x=?newx+?dx,y=?newy) == ''">
		    	<lvar name="ent" value="bdash_main::get_entity(x=?newx,y=?newy)" />
			<if eval="!?(#ent).moving">
			    <var entity="#ent" name="dx" value="?dx" />
			    <var entity="#ent" name="dy" value="?dy" />
			    <call entity="#ent" event="startmove" />
			    <call event="startmove" />
		    	</if>
		    </if>
		</if>
	    </event>

	    <!--
	      - Perform a push if possible.
	      - Don't move afterwards.
	      -->
	    <event name="trypush_dontmove">
		<if eval="bdash_main::get_entity(x=?newx+?dx,y=?newy+?dy) == ''">
		    <lvar name="ent" value="bdash_main::get_entity(x=?newx,y=?newy)" />
		    <if eval="!?(#ent).moving">
			<var entity="#ent" name="dx" value="?dx" />
			<var entity="#ent" name="dy" value="?dy" />
			<call entity="#ent" event="startmove" />
		    </if>
		</if>
	    </event>

	    <!--
	      - Perform a push if possible.
	      - Don't move afterwards.
	      -->
	    <event name="trypush_horizontal_dontmove">
	    	<if eval="?dy==0">
		    <if eval="bdash_main::get_entity(x=?newx+?dx,y=?newy) == ''">
		    	<lvar name="ent" value="bdash_main::get_entity(x=?newx,y=?newy)" />
			<if eval="!?(#ent).moving">
			    <var entity="#ent" name="dx" value="?dx" />
			    <var entity="#ent" name="dy" value="?dy" />
			    <call entity="#ent" event="startmove" />
		    	</if>
		    </if>
		</if>
	    </event>

	    <event name="takediamond">
		<sound name="bloop" loop="false" />
		<call entity="bdash_main" event="addscore">
		    <par id="parid(score)" value="1" />
		</call>
	    </event>
	    <event name="takeapple">
		<sound name="bloop" loop="false" />
		<call entity="bdash_main" event="addscore">
		    <par id="parid(score)" value="5" />
		</call>
	    </event>
	    <event name="takemushroom">
		<call entity="bdash_main" event="new_explosion">
		    <par id="parid(x)" value="?x" />
		    <par id="parid(y)" value="?y" />
		</call>
	    </event>
	    <event name="takekey">
		<lvar name="color" value="strsub(bdash_main::get_blocktype(x=?newx,y=?newy),1,1)" />
		<var entity="bdash_main" name="havekey+#color" value="?bdash_main.(havekey+#color)+1" />
	    </event>

	    <!--
	      - Check if a rotate is possible and perform the rotate
	      - if so. Uses ?dx and ?dy to get the rotate direction and
	      - ?x and ?y for current position.
	      -->
	    <event name="checkrot">
	        <if eval="?moving">
		    <stop />
		</if>
		<var name="newx" value="?x+?dx" />
		<var name="newy" value="?y+?dy" />
		<lvar name="bt" value="bdash_main::get_blocktype(x=?newx,y=?newy)" />
		<lvar name="dest_bt" value="?bdash_main.rotate[#bt]" />
		<if eval="#dest_bt != ''">
		    <call event="clearblock_nocheck" />
		    <call entity="bdash_main" event="createblock">
		        <par id="parid(blocktype)" value="#dest_bt" />
		        <par id="parid(x)" value="?newx" />
		        <par id="parid(y)" value="?newy" />
		    </call>
		</if>
	    </event>

	    <!--
	      - Check if a take is possible and perform the take
	      - if so. Uses ?dx and ?dy to get the take direction and
	      - ?x and ?y for current position.
	      - This routine will fire one of the 'checktake_' events below
	      - depending on the contents of the block we want to take.
	      -->
	    <event name="checktake">
	        <if eval="?moving">
		    <stop />
		</if>
		<var name="newx" value="?x+?dx" />
		<var name="newy" value="?y+?dy" />
		<call event="checktake_+bdash_main::get_blocktype(x=?newx,y=?newy)" />
	    </event>

	    <event name="checktake_. ">
	    </event>
	    <event name="checktake_##">
	    	<call event="clearblock_check" />
	    </event>
	    <event name="checktake_#B">
	    </event>
	    <event name="checktake_#R">
	    	<call event="trypush_horizontal_dontmove" />
	    </event>
	    <event name="checktake_OO">
	    	<call event="trypush_horizontal_dontmove" />
	    </event>
	    <event name="checktake_Oo">
	    </event>
	    <event name="checktake_=L">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=U">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=1">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=2">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=3">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=4">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=a">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=b">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=c">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=d">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=+">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=&">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=|">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_=^">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_#W">
	    	<call event="trypush_dontmove" />
	    </event>
	    <event name="checktake_Xx">
	    	<call event="trypush_horizontal_dontmove" />
	    </event>
	    <event name="checktake_KR">
	    	<call event="takekey" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_KG">
	    	<call event="takekey" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_KB">
	    	<call event="takekey" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_KY">
	    	<call event="takekey" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_XX">
	    	<call event="takediamond" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_Ma">
	    	<call event="takeapple" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_Mb">
	    	<call event="takeapple" />
		<call event="clearblock_check" />
	    </event>
	    <event name="checktake_Mm">
	    	<call event="takemushroom" />
		<call event="clearblock_nocheck" />
	    </event>
	    <event name="tryfattube_move">
		<call entity="?bdash_main.hero" event="start_fattube_move">
		    <par id="parid(dx)" value="?dx" />
		    <par id="parid(dy)" value="?dy" />
		</call>
	    </event>

	    <!--
	      - Check if a move is possible and perform the move
	      - if so. Uses ?dx and ?dy to get the move direction and
	      - ?x and ?y for current position.
	      - This routine will fire one of the 'checkmove_' events below
	      - depending on the contents of the block we move too.
	      -->
	    <event name="checkmove">
	        <if eval="?moving">
		    <stop />
		</if>
		<lvar name="cur_bt" value="bdash_main::get_blocktype(x=?x,y=?y)" />
		<if eval="#cur_bt=='>R'">
		    <if eval="?dx!=1"> <stop/> </if>
		</if>
		<if eval="#cur_bt=='>L'">
		    <if eval="?dx!=-1"> <stop/> </if>
		</if>
		<if eval="#cur_bt=='>U'">
		    <if eval="?dy!=-1"> <stop/> </if>
		</if>
		<if eval="#cur_bt=='>D'">
		    <if eval="?dy!=1"> <stop/> </if>
		</if>
		<var name="newx" value="?x+?dx" />
		<var name="newy" value="?y+?dy" />
		<call event="checkmove_+bdash_main::get_blocktype(x=?newx,y=?newy)" />
	    </event>

	    <event name="checkmove_. ">
		<call event="startmove" />
	    </event>
	    <event name="checkmove_DO">
		<call event="startmove" />
	    </event>
	    <event name="checkmove_##">
	    	<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_#B">
	    </event>
	    <event name="checkmove_#R">
	    	<call event="trypush_horizontal" />
	    </event>
	    <event name="checkmove_>R">
	    	<call event="startmove" />
	    </event>
	    <event name="checkmove_>L">
	    	<call event="startmove" />
	    </event>
	    <event name="checkmove_>U">
	    	<call event="startmove" />
	    </event>
	    <event name="checkmove_>D">
	    	<call event="startmove" />
	    </event>
	    <event name="checkmove_OO">
	    	<call event="trypush_horizontal" />
	    </event>
	    <event name="checkmove_Oo">
		<call event="startmove" />
	    </event>
	    <event name="checkmove_=L">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=U">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=1">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=2">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=3">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=4">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=a">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=b">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=c">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=d">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=+">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=&">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=|">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_=^">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_#W">
	    	<call event="trypush" />
	    </event>
	    <event name="checkmove_Xx">
	    	<call event="trypush_horizontal" />
	    </event>
	    <event name="checkmove_:L">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:U">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:1">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:2">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:3">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:4">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:#">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_:%">
	    	<call event="tryfattube_move" />
	    </event>
	    <event name="checkmove_KR">
	    	<call event="takekey" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_KG">
	    	<call event="takekey" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_KB">
	    	<call event="takekey" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_KY">
	    	<call event="takekey" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_XX">
	    	<call event="takediamond" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_Ma">
	    	<call event="takeapple" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_Mb">
	    	<call event="takeapple" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>
	    <event name="checkmove_Mm">
	    	<call event="takemushroom" />
		<call event="clearblock_nocheck" />
		<call event="startmove" />
	    </event>

	    <!--
	      - This block doesn't support falling down.
	      -->
	    <event name="falldown">
		<return value="false" />
	    </event>

	    <!--
	      - Movement events.
	      -->
	    <event name="pckeyinput_bomb1">
	    	<if eval="!?bdash_main.maze[?x,?y]">
		    <call entity="bdash_main" event="createblock">
		        <par id="parid(blocktype)" value="'Oo'" />
		        <par id="parid(x)" value="?x" />
		        <par id="parid(y)" value="?y" />
		    </call>
		    <call entity="bdash_main" event="ifempty_checkfall">
		        <par id="parid(x)" value="?x" />
		        <par id="parid(y)" value="?y+1" />
	    	    </call>
	        </if>
	    </event>
	    <event name="pckeyinput_move_right1">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_left1">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_down1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_up1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_right_">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_left_">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_down_">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_up_">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_take_right1">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_left1">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_down1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_up1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_right_">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_left_">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_down_">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checktake" />
	    </event>
	    <event name="pckeyinput_take_up_">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkrot" />
	    </event>
	    <event name="pckeyinput_rot_right1">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checkrot" />
	    </event>
	    <event name="pckeyinput_rot_left1">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checkrot" />
	    </event>
	    <event name="pckeyinput_rot_down1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checkrot" />
	    </event>
	    <event name="pckeyinput_rot_up1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkrot" />
	    </event>
	</script>

	<!-- *****************************************************
	  - Generic boulderdash block.
	  - Every block maintains the following variables:
	  -    ?x, ?y: position of block (in the maze)
	  -    ?dim: dimension of this block (constant)
	  -    ?blocktype: type of this block (constant)
	  -    ?pcbb: pcbillboard instance (constant)
	  -    ?moving: true if this block is moving
	  -    ?power: amount of power
	  -  ***************************************************** -->
        <script name="bdash_block">
	    <!--
	      - Initialize this block.
	      - It assumes ?bdash_main.x and ?bdash_main.y are set to the
	      - x,y index of the block. And it also assumes ?bdash_main.blocktype
	      - is set. It also uses the ?bdash_main.material_ array.
	      - Also uses ?bdash_main.blockdim.
	      -->
	    <event name="init">
	        <var name="blocktype" value="?bdash_main.blocktype" />
		<var name="dim" value="?bdash_main.blockdim" />

	        <createpropclass name="pcbillboard" />
	        <createpropclass name="pcproperties" />
		<var name="pcbb" value="pc(pcbillboard)" />
		<default propclass="?pcbb" />
	        <property id="propid(name)" value="block" />
	        <property id="propid(materialname)" value="?bdash_main.material[?blocktype]" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="false" />
	        <property id="propid(restack)" value="false" />
	        <property id="propid(width)" value="640+?dim" />
	        <property id="propid(height)" value="640+?dim" />
	        <property id="propid(layer)" value="game" />
		<bb_toback />
	    	<call event="reinit" />
	    </event>

	    <!--
	      - Re-initialize this block.
	      - It assumes ?bdash_main.x and ?bdash_main.y are set to the
	      - x,y index of the block. And it also assumes ?bdash_main.blocktype
	      - is set. It also uses the ?bdash_main.material_ array.
	      - Also uses ?bdash_main.blockdim.
	      -->
	    <event name="reinit">
		<var name="moving" value="false" />
		<var name="power" value="0" />
	        <var name="x" value="?bdash_main.x" />
	        <var name="y" value="?bdash_main.y" />
		<default propclass="?pcbb" />
		<bb_move x="?x*?dim" y="?y*?dim" delta="0" />
	    </event>

	    <!--
	      - Operations that need to happen when the block is removed from
	      - the maze.
	      -->
	    <event name="cleanup">
	    </event>

	    <!--
	      - This block doesn't support falling down.
	      -->
	    <event name="falldown">
		<return value="false" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a non-movable block in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_nonmovable">
	    <superscript name="bdash_block" />
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a movable block in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_movable">
	    <superscript name="bdash_block" />

	    <!--
	      - Initialize this block.
	      -->
	    <event name="init">
		<var name="speed" value="?bdash_main.fallspeed" />
	        <createpropclass name="pctimer" />
	    	<super />
	    </event>
	    <event name="cleanup">
	    	<super />
		<action propclass="pc(pctimer)" id="propid(Clear)" />
	    </event>

	    <!--
	      - The move ends.
	      -->
	    <event name="pctimer_wakeup">
	        <if eval="?moving">
		    <if eval="?twosteps">
		        <!-- Movement in two steps -->
			<var name="twosteps" value="false" />
			<action propclass="pc(pctimer)" id="propid(WakeUp)">
			    <par id="parid(time)" value="int(500*?speed)" />
			    <par id="parid(repeat)" value="false" />
			</action>
			<bb_move x="?x*?dim" y="?y*?dim" delta="int(500*?speed)" />
			<stop />
		    </if>
		    <var name="moving" value="false" />
		    <call event="endmove" />
		</if>
	    </event>

	    <event name="startmove">
		<call entity="bdash_main" event="startmove_block">
		    <par id="parid(entity)" value="ent()" />
		    <par id="parid(dx)" value="?dx" />
		    <par id="parid(dy)" value="?dy" />
		</call>
		<var name="x" value="?x+?dx" />
		<var name="y" value="?y+?dy" />
		<var name="moving" value="true" />
		<if eval="?dx && ?dy == 1">
		    <true>
		    	<!-- Movement is in two steps -->
			<var name="twosteps" value="true" />
			<action propclass="pc(pctimer)" id="propid(WakeUp)">
			    <par id="parid(time)" value="int(500*?speed)" />
			    <par id="parid(repeat)" value="false" />
			</action>
			<bb_move x="?x*?dim" y="?y*?dim-?dim/2" delta="int(500*?speed)" />
		    </true>
		    <false>
			<var name="twosteps" value="false" />
			<action propclass="pc(pctimer)" id="propid(WakeUp)">
			    <par id="parid(time)" value="int(1000*?speed)" />
			    <par id="parid(repeat)" value="false" />
			</action>
			<bb_move x="?x*?dim" y="?y*?dim" delta="int(1000*?speed)" />
	            </false>
	        </if>
	    </event>

	    <event name="endmove">
	    	<!-- Check if we fall on something that can explode -->
	    	<if eval="?dy!=0">
		    <lvar name="ent" value="bdash_main::get_entity(x=?x,y=?y+1)" />
		    <if eval="#ent">
		    	<lvar name="blocktype" value="?(#ent).blocktype" />
			<lvar name="explode" value="?bdash_main.explode[#blocktype]" />
			<if eval="#explode==1">
			    <true>
		                <call entity="bdash_main" event="new_explosion">
			            <par id="parid(x)" value="?x" />
			            <par id="parid(y)" value="?y+1" />
		                </call>
			    </true>
			    <false>
			        <if eval="#explode==2">
		                    <call entity="bdash_main" event="new_diamond_explosion">
			                <par id="parid(x)" value="?x" />
			                <par id="parid(y)" value="?y+1" />
		                    </call>
			        </if>
			    </false>
			</if>
		    </if>
		</if>
		<action propclass="pc(pctimer)" id="propid(Clear)" />
		<call entity="bdash_main" event="endmove_block">
		    <par id="parid(entity)" value="ent()" />
		</call>
	    </event>

	    <!--
	      - This block supports falling down. Uses @dx and @dy for
	      - the fall direction.
	      -->
	    <event name="falldown">
	        <if eval="?moving">
		    <return value="false" />
		</if>
		<var name="dx" value="@dx" />
		<var name="dy" value="@dy" />
		<call event="startmove" />
		<return value="true" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a pushable block in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_pushable">
	    <superscript name="bdash_block" />

	    <!--
	      - Initialize this block.
	      -->
	    <event name="init">
		<var name="speed" value="?bdash_main.pushspeed" />
	        <createpropclass name="pctimer" />
		<super />
	    </event>
	    <event name="cleanup">
		<action propclass="pc(pctimer)" id="propid(Clear)" />
	    </event>

	    <!--
	      - The move ends.
	      -->
	    <event name="pctimer_wakeup">
	        <if eval="?moving">
		    <var name="moving" value="false" />
		    <call event="endmove" />
		</if>
	    </event>

	    <event name="startmove">
		<call entity="bdash_main" event="startmove_block">
		    <par id="parid(entity)" value="ent()" />
		    <par id="parid(dx)" value="?dx" />
		    <par id="parid(dy)" value="?dy" />
		</call>
		<var name="x" value="?x+?dx" />
		<var name="y" value="?y+?dy" />
		<var name="moving" value="true" />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="int(1000*?speed)" />
		    <par id="parid(repeat)" value="false" />
		</action>
		<bb_move x="?x*?dim" y="?y*?dim" delta="int(1000*?speed)" />
	    </event>

	    <event name="endmove">
		<action propclass="pc(pctimer)" id="propid(Clear)" />
		<call entity="bdash_main" event="endmove_block">
		    <par id="parid(entity)" value="ent()" />
		</call>
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a tube in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_tube">
	    <superscript name="bdash_pushable" />

	    <event name="init">
	        <super />
		<var name="bitout" value="?bdash_main.tubeout[?blocktype]" />
		<var name="bitin" value="?bdash_main.tubein[?blocktype]" />
		<var name="logic" value="logicdef" />
		<if eval="?blocktype=='=&'">
		    <var name="logic" value="logicand" />
		</if>
		<if eval="?blocktype=='=|'">
		    <var name="logic" value="logicor" />
		</if>
		<if eval="?blocktype=='=^'">
		    <var name="logic" value="logicxor" />
		</if>
	    </event>
	    <event name="reinit">
	    	<super />
		<!-- ?totalpower is used to detect big power drops so
		     we can shut down faster -->
		<var name="totalpower" value="0" />
	        <property propclass="?pcbb"
			id="propid(color)" value="rgb(.2,.2,.2)" />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="50" />
		    <par id="parid(repeat)" value="true" />
		</action>
	    </event>

	    <event name="startmove">
	        <super />
	    </event>
	    <event name="endmove">
	        <super />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="50" />
		    <par id="parid(repeat)" value="true" />
		</action>
	    </event>

	    <event name="logicdef">
	    	<return value="true" />
	    </event>
	    <event name="logicand">
	    	<return value="@count>=2" />
	    </event>
	    <event name="logicor">
	    	<return value="@count>=1" />
	    </event>
	    <event name="logicxor">
	    	<return value="@count==1" />
	    </event>

	    <event name="pctimer_wakeup">
	        <if eval="?moving">
	            <super />
	            <stop />
	    	</if>
		<if eval="!?power">
		    <lvar name="p1" value="check_power(dx=0,dy=-1,mask=1)" />
		    <lvar name="p2" value="check_power(dx=0,dy=1,mask=2)" />
		    <lvar name="p3" value="check_power(dx=1,dy=0,mask=8)" />
		    <lvar name="p4" value="check_power(dx=-1,dy=0,mask=4)" />
		    <lvar name="pm" value="0" />
		    <if eval="#p1"> <lvar name="pm" value="#pm+1" /> </if>
		    <if eval="#p2"> <lvar name="pm" value="#pm+2" /> </if>
		    <if eval="#p3"> <lvar name="pm" value="#pm+8" /> </if>
		    <if eval="#p4"> <lvar name="pm" value="#pm+4" /> </if>
		    <!-- Remember where we got our power from -->
		    <var name="powerinput" value="#pm" />
		    <if eval="#pm">
		        <lvar name="p" value="max(max(#p1,#p2),max(#p3,#p4))-1" />
		        <if eval="#p>0">
			    <lvar name="count" value="sign(#p1)+sign(#p2)+sign(#p3)+sign(#p4)" />
			    <call event="?logic">
			        <par id="parid(count)" value="#count" />
			        <return var="rc" />
			    </call>
			    <if eval="?rc">
			        <!-- Ok, we can power on -->
				<var name="power" value="max(1,#p-1)" />
				<call event="powerup" />
			    </if>
		        </if>
		    </if>
		    <stop />
		</if>

		<lvar name="p1" value="check_power(dx=0,dy=-1,mask=1)" />
		<lvar name="p2" value="check_power(dx=0,dy=1,mask=2)" />
		<lvar name="p3" value="check_power(dx=1,dy=0,mask=8)" />
		<lvar name="p4" value="check_power(dx=-1,dy=0,mask=4)" />
		<lvar name="pm" value="0" />
		<if eval="#p1"> <lvar name="pm" value="#pm+1" /> </if>
		<if eval="#p2"> <lvar name="pm" value="#pm+2" /> </if>
		<if eval="#p3"> <lvar name="pm" value="#pm+8" /> </if>
		<if eval="#p4"> <lvar name="pm" value="#pm+4" /> </if>
		<if eval="(#pm & ?powerinput) != ?powerinput">
		    <var name="power" value="0" />
		    <call event="powerdown" />
		    <stop />
		</if>
		<var name="power" value="max(max(#p1,#p2),max(#p3,#p4))-1" />
		<if eval="?power<=0">
		    <var name="power" value="0" />
		    <call event="powerdown" />
		    <stop />
	        </if>
		<lvar name="count" value="sign(#p1)+sign(#p2)+sign(#p3)+sign(#p4)" />
		<call event="?logic">
		    <par id="parid(count)" value="#count" />
		    <return var="rc" />
		</call>
		<if eval="!?rc">
		    <var name="power" value="0" />
		    <call event="powerdown" />
		    <stop />
	        </if>
	    </event>

	    <event name="check_power">
	    	<if eval="?bitin&@mask">
		    <lvar name="ent" value="?bdash_main.maze[?x+@dx,?y+@dy]" />
		    <if eval="#ent==''"> <return value="0" /> </if>
		    <lvar name="p" value="?#ent.power" />
		    <if eval="#p > 0">
		        <if eval="?#ent.bitout&@mask">
		            <return value="#p" />
		        </if>
		    </if>
	        </if>
		<return value="0" />
	    </event>

	    <event name="powerup">
	        <property propclass="?pcbb"
			id="propid(color)" value="rgb(1,1,1)" />
	    </event>

	    <event name="powerdown">
	        <property propclass="?pcbb"
			id="propid(color)" value="rgb(.2,.2,.2)" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a tube key in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_tube_key">
	    <superscript name="bdash_tube" />

	    <event name="reinit">
	    	<super />
	    	<var name="takekey" value="false" />
	    </event>
	    <event name="cleanup">
	    	<super />
	    	<if eval="?takekey">
		    <lvar name="color" value="strsub(?blocktype,1,1)" />
		    <var entity="bdash_main" name="havekey+#color" value="?bdash_main.(havekey+#color)-1" />
		</if>
	    </event>

	    <event name="powerup">
	    	<super />
		<if eval="!?takekey">
		    <lvar name="color" value="strsub(?blocktype,1,1)" />
		    <var entity="bdash_main" name="havekey+#color" value="?bdash_main.(havekey+#color)+1" />
		    <var name="takekey" value="true" />
	    	</if>
	    </event>

	    <event name="powerdown">
	    	<super />
		<if eval="?takekey">
		    <lvar name="color" value="strsub(?blocktype,1,1)" />
		    <var entity="bdash_main" name="havekey+#color" value="?bdash_main.(havekey+#color)-1" />
		    <var name="takekey" value="false" />
	    	</if>
	    </event>
	</script>


	<!-- *****************************************************
	  - This script handles all operations on a tube power station in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_tube_power">
	    <superscript name="bdash_block" />

	    <event name="init">
	        <createpropclass name="pctimer" />
	        <super />
		<var name="bitout" value="?bdash_main.tubeout[?blocktype]" />
		<var name="bitin" value="?bdash_main.tubein[?blocktype]" />
	    </event>
	    <event name="reinit">
	    	<super />
	        <var name="power" value="0" />
	        <property propclass="?pcbb"
			id="propid(color)" value="rgb(.2,.2,.2)" />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="200" />
		    <par id="parid(repeat)" value="true" />
		</action>
		<default propclass="?pcbb" />
	        <property id="propid(materialnamefast)" value="?bdash_main.material[?blocktype]" />
	    </event>
	    <event name="cleanup">
	    	<super />
		<action propclass="pc(pctimer)" id="propid(Clear)" />
	    </event>

	    <event name="pctimer_wakeup">
	    	<!--
		  - If we are out of power we check if there are any diamonds in the vicinity.
		  - If yes, we eat them for power.
		  -->
	    	<if eval="?power<8">
		    <if eval="bdash_main::get_blocktype(x=?x,y=?y-1)=='XX'">
			<call entity="bdash_main" event="clearblock_check">
			    <par id="parid(x)" value="?x" />
			    <par id="parid(y)" value="?y-1" />
		        </call>
			<call event="powerup" />
			<stop />
		    </if>
		    <if eval="bdash_main::get_blocktype(x=?x,y=?y+1)=='XX'">
			<call entity="bdash_main" event="clearblock_check">
			    <par id="parid(x)" value="?x" />
			    <par id="parid(y)" value="?y+1" />
		        </call>
			<call event="powerup" />
			<stop />
		    </if>
		    <if eval="bdash_main::get_blocktype(x=?x-1,y=?y)=='XX'">
			<call entity="bdash_main" event="clearblock_check">
			    <par id="parid(x)" value="?x-1" />
			    <par id="parid(y)" value="?y" />
		        </call>
			<call event="powerup" />
			<stop />
		    </if>
		    <if eval="bdash_main::get_blocktype(x=?x+1,y=?y)=='XX'">
			<call entity="bdash_main" event="clearblock_check">
			    <par id="parid(x)" value="?x+1" />
			    <par id="parid(y)" value="?y" />
		        </call>
			<call event="powerup" />
			<stop />
		    </if>
		</if>
		<!-- Slowly deplete power otherwise -->
		<if eval="?power>0">
		    <var name="power" value="?power-1" />
		    <default propclass="?pcbb" />
		    <switch eval="(?power-3)/25">
		        <case value="-1"> <property id="propid(materialnamefast)" value="tube_power" /> </case>
		        <case value="0"> <property id="propid(materialnamefast)" value="tube_power_25" /> </case>
		        <case value="1"> <property id="propid(materialnamefast)" value="tube_power_50" /> </case>
		        <case value="2"> <property id="propid(materialnamefast)" value="tube_power_75" /> </case>
		        <default> <property id="propid(materialnamefast)" value="tube_power_full" /> </default>
		    </switch>
		    <if eval="?power<=0">
		        <call event="powerdown" />
		    </if>
	        </if>
	    </event>

	    <event name="powerup">
	        <var name="power" value="90" />
	        <property propclass="?pcbb"
			id="propid(color)" value="rgb(1,1,1)" />
	    </event>

	    <event name="powerdown">
	        <var name="power" value="0" />
		<default propclass="?pcbb" />
		<property id="propid(materialnamefast)" value="tube_power" /> 
	        <property propclass="?pcbb"
			id="propid(color)" value="rgb(.2,.2,.2)" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a diamond in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_diamond">
	    <superscript name="bdash_movable" />
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a bomb in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_bomb">
	    <superscript name="bdash_movable" />

	    <event name="endmove">
	        <!-- Don't explode for pure horizontal moves -->
	    	<if eval="?dy!=0">
		    <if eval="?bdash_main.maze[?x,?y+1] != ''">
		        <call entity="bdash_main" event="new_explosion">
			    <par id="parid(x)" value="?x" />
			    <par id="parid(y)" value="?y" />
		        </call>
		    </if>
		</if>
		<super />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a diamond bomb in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_diamond_bomb">
	    <superscript name="bdash_movable" />

	    <event name="endmove">
	        <!-- Don't explode for pure horizontal moves -->
	    	<if eval="?dy!=0">
		    <if eval="?bdash_main.maze[?x,?y+1] != ''">
		        <call entity="bdash_main" event="new_diamond_explosion">
			    <par id="parid(x)" value="?x" />
			    <par id="parid(y)" value="?y" />
		        </call>
		    </if>
		</if>
		<super />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a movable monster in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_monster">
	    <superscript name="bdash_block" />

	    <!--
	      - Initialize this block.
	      -->
	    <event name="init">
		<var name="speed" value="?bdash_main.fallspeed" />
	        <createpropclass name="pctimer" />
		<super />
	    </event>
	    <event name="reinit">
		<super />
		<call event="waitfornewmove" />
	    </event>
	    <event name="cleanup">
		<action propclass="pc(pctimer)" id="propid(Clear)" />
	    </event>

	    <!--
	      - The move ends.
	      -->
	    <event name="pctimer_wakeup">
	        <if eval="?moving">
		    <true>
		        <var name="moving" value="false" />
		        <call event="endmove" />
		    </true>
		    <false>
		    	<call event="decidenewmove" />
		    </false>
		</if>
	    </event>

	    <!--
	      - Subscripts can override this to decide on a new move.
	      -->
	    <event name="decidenewmove">
	    </event>

	    <!--
	      - Subscripts can call this to wait a bit and then decide
	      - on a new move again.
	      -->
	    <event name="waitfornewmove">
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <!-- Add a small random amount to avoid a hickup at exactly the same time for
		         all moving objects -->
		    <par id="parid(time)" value="150+int(rand(50.0))" />
		    <par id="parid(repeat)" value="false" />
		</action>
	    </event>

	    <!--
	      - Routine to calculate ?dx and ?dy based on ?dxdy.
	      -->
	    <event name="calcdxdy">
		<!-- Set ?dx and ?dy based on the four possible outcomes -->
		<if eval="?dxdy&2">
		    <true>
		        <var name="dx" value="0" />
		        <var name="dy" value="if(?dxdy&1,1,-1)" />
		    </true>
		    <false>
		        <var name="dx" value="if(?dxdy&1,1,-1)" />
		        <var name="dy" value="0" />
		    </false>
		</if>
	    </event>

	    <!--
	      - Rotate ?dx and ?dy two steps to the left (there are 8
	      - rotation positions).
	      -->
	    <event name="rotateleft2">
	        <lvar name="keep" value="?dx" />
		<var name="dx" value="-?dy" />
		<var name="dy" value="#keep" />
	    </event>

	    <!--
	      - Rotate ?dx and ?dy two steps to the right (there are 8
	      - rotation positions).
	      -->
	    <event name="rotateright2">
	        <lvar name="keep" value="?dx" />
		<var name="dx" value="?dy" />
		<var name="dy" value="-#keep" />
	    </event>

	    <!--
	      - Rotate ?dx and ?dy one step to the left (there are 8
	      - rotation positions).
	      -->
	    <event name="rotateleft">
	    	<if eval="!?dx">
		    <if eval="!?dy">
		        <!-- dx==0 dy==0 -->
			<!-- Nothing changes -->
		        <stop/>
		    </if>
		    <if eval="?dy==1">
		        <!-- dx==0 dy==1 -->
			<var name="dx" value="-1" />
		        <stop/>
		    </if>
		    <!-- dx==0 dy==-1 -->
		    <var name="dx" value="1" />
		    <stop/>
		</if>
	        <if eval="?dx==1">
		    <if eval="!?dy">
		        <!-- dx==1 dy==0 -->
			<var name="dy" value="1" />
		        <stop/>
		    </if>
		    <if eval="?dy==1">
		        <!-- dx==1 dy==1 -->
			<var name="dx" value="0" />
		        <stop/>
		    </if>
		    <!-- dx==1 dy==-1 -->
		    <var name="dy" value="0" />
		    <stop/>
		</if>
		<if eval="!?dy">
		    <!-- dx==-1 dy==0 -->
		    <var name="dy" value="-1" />
		    <stop/>
		</if>
		<if eval="?dy==1">
		    <!-- dx==-1 dy==1 -->
		    <var name="dy" value="0" />
		    <stop/>
		</if>
		<!-- dx==-1 dy==-1 -->
		<var name="dx" value="0" />
	    </event>

	    <!--
	      - Rotate ?dx and ?dy one step to the right (there are 8
	      - rotation positions).
	      -->
	    <event name="rotateright">
	    	<if eval="!?dx">
		    <if eval="!?dy">
		        <!-- dx==0 dy==0 -->
			<!-- Nothing changes -->
		        <stop/>
		    </if>
		    <if eval="?dy==1">
		        <!-- dx==0 dy==1 -->
			<var name="dx" value="1" />
		        <stop/>
		    </if>
		    <!-- dx==0 dy==-1 -->
		    <var name="dx" value="-1" />
		    <stop/>
		</if>
	        <if eval="?dx==1">
		    <if eval="!?dy">
		        <!-- dx==1 dy==0 -->
			<var name="dy" value="-1" />
		        <stop/>
		    </if>
		    <if eval="?dy==1">
		        <!-- dx==1 dy==1 -->
			<var name="dy" value="0" />
		        <stop/>
		    </if>
		    <!-- dx==1 dy==-1 -->
		    <var name="dx" value="0" />
		    <stop/>
		</if>
		<if eval="!?dy">
		    <!-- dx==-1 dy==0 -->
		    <var name="dy" value="1" />
		    <stop/>
		</if>
		<if eval="?dy==1">
		    <!-- dx==-1 dy==1 -->
		    <var name="dx" value="0" />
		    <stop/>
		</if>
		<!-- dx==-1 dy==-1 -->
		<var name="dy" value="0" />
	    </event>

	    <event name="startmove">
		<call entity="bdash_main" event="startmove_block">
		    <par id="parid(entity)" value="ent()" />
		    <par id="parid(dx)" value="?dx" />
		    <par id="parid(dy)" value="?dy" />
		</call>
		<var name="x" value="?x+?dx" />
		<var name="y" value="?y+?dy" />
		<var name="moving" value="true" />
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="int(1000*?speed)" />
		    <par id="parid(repeat)" value="false" />
		</action>
		<bb_move x="?x*?dim" y="?y*?dim" delta="int(1000*?speed)" />
	    </event>

	    <event name="endmove">
		<action propclass="pc(pctimer)" id="propid(Clear)" />
		<call entity="bdash_main" event="endmove_block">
		    <par id="parid(entity)" value="ent()" />
		</call>
		<call event="decidenewmove" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a mushroom monster in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_mushroom_monster">
	    <superscript name="bdash_monster" />

	    <event name="decidenewmove">
	    	<lvar name="ax" value="abs(?bdash_main.hero_x-?x)" />
	    	<lvar name="ay" value="abs(?bdash_main.hero_y-?y)" />
		<if eval="#ax<10 && #ay<10">
		    <var name="dx" value="sign(?bdash_main.hero_x-?x)"/>
		    <var name="dy" value="sign(?bdash_main.hero_y-?y)"/>
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
		        <call event="startmove" />
			<stop />
		    </if>
		    <call event="waitfornewmove" />
		    <stop />
		</if>
	        <var name="dxdy" value="int(rand(4.0))" />
		<call event="calcdxdy" />
		<lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		<if eval="!#ent">
		    <call event="startmove" />
		    <stop />
		</if>
		<call event="waitfornewmove" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a apple monster in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_apple_monster">
	    <superscript name="bdash_monster" />

	    <event name="reinit">
	    	<super />
	        <var name="retreat" value="false" />
	    </event>

	    <event name="decidenewmove">
	    	<lvar name="ax" value="abs(?bdash_main.hero_x-?x)" />
	    	<lvar name="ay" value="abs(?bdash_main.hero_y-?y)" />
		<if eval="#ax<10 && #ay<10">
		    <!-- Flee mode -->
		    <var name="dx" value="sign(?x-?bdash_main.hero_x)"/>
		    <var name="dy" value="sign(?y-?bdash_main.hero_y)"/>
		    <if eval="?retreat">
		    	<true>
			    <!--
			      - We were retreating last time. To make sure we can
			      - sufficiently retreat we try a few times more (random).
			      -->
			    <if eval="!int(rand(2.0))">
			        <var name="retreat" value="false"/>
			    </if>
			</true>
			<false>
			    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
			    <if eval="!#ent">
				<call event="startmove" />
				<stop />
			    </if>
			</false>
		    </if>
		    <!-- Based on a random value we first start trying left or right -->
		    <if eval="int(rand(2.0))">
		    	<true>
		            <lvar name="dir1" value="rotateleft" />
		            <lvar name="dir2" value="rotateright" />
		        </true>
		    	<false>
		            <lvar name="dir1" value="rotateright" />
		            <lvar name="dir2" value="rotateleft" />
		    	</false>
		    </if>

		    <lvar name="rdx" value="?dx" />
		    <lvar name="rdy" value="?dy" />
		    <call event="#dir1" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
		        <call event="startmove" />
			<stop />
		    </if>
		    <var name="dx" value="#rdx" />
		    <var name="dy" value="#rdy" />
		    <call event="#dir2" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
		        <call event="startmove" />
			<stop />
		    </if>
		    <call event="#dir2" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
		        <call event="startmove" />
			<stop />
		    </if>
		    <var name="dx" value="#rdx" />
		    <var name="dy" value="#rdy" />
		    <call event="#dir1+'2'" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
		        <call event="startmove" />
			<stop />
		    </if>
		    <call event="#dir1" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
			<var name="retreat" value="true"/>
		        <call event="startmove" />
			<stop />
		    </if>
		    <var name="dx" value="#rdx" />
		    <var name="dy" value="#rdy" />
		    <call event="#dir2+'2'" />
		    <call event="#dir2" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
			<var name="retreat" value="true"/>
		        <call event="startmove" />
			<stop />
		    </if>
		    <call event="waitfornewmove" />
		    <stop />
		</if>
	        <var name="dxdy" value="int(rand(4.0))" />
		<call event="calcdxdy" />
		<lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		<if eval="!#ent">
		    <call event="startmove" />
		    <stop />
		</if>
		<call event="waitfornewmove" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a diamond monster in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_diamond_monster">
	    <superscript name="bdash_monster" />

	    <event name="reinit">
	        <super />
		<var name="maintain_direction" value="0" />
	    </event>

	    <event name="decidenewmove">
	    	<if eval="?maintain_direction > 0">
		    <var name="maintain_direction" value="?maintain_direction-1" />
		    <lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		    <if eval="!#ent">
		        <call event="startmove" />
		        <stop />
		    </if>
		    <var name="maintain_direction" value="0" />
		    <call event="waitfornewmove" />
		    <stop />
		</if>

	        <var name="dxdy" value="int(rand(6.0))" />
		<if eval="?dxdy>=4">
		    <!-- With some chance we do nothing -->
		    <call event="waitfornewmove" />
		    <stop />
		</if>
		<call event="calcdxdy" />
		<lvar name="ent" value="bdash_main::get_entity(x=?x+?dx,y=?y+?dy)" />
		<if eval="!#ent">
		    <!-- For a random amount of time we maintain our current heading -->
		    <var name="maintain_direction" value="int(rand(5.0))" />
		    <call event="startmove" />
		    <stop />
		</if>
		<call event="waitfornewmove" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a timed bomb in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_timedbomb">
	    <superscript name="bdash_movable" />

	    <!--
	      - Re-initialize this block.
	      -->
	    <event name="reinit">
	    	<super />
		<var name="timeout" value="-1" />
		<var name="anim" value="200" />
		<var name="offset" value="0" />
		<var name="origx" value="property(?pcbb,propid(x))" />
		<var name="origy" value="property(?pcbb,propid(y))" />
		<action propclass="pc(pctimer)" id="propid(WakeUpFrame)" />
	    </event>

	    <event name="endmove">
	        <super />
		<action propclass="pc(pctimer)" id="propid(WakeUpFrame)" />
	    </event>

	    <event name="pctimer_wakeupframe">
		<if eval="?timeout==-1">
		    <var name="timeout" value="2000" />
		    <stop />
		</if>
		<var name="timeout" value="?timeout-@elapsedticks" />
		<if eval="?timeout<0">
		    <call entity="bdash_main" event="clearblock_nocheck">
			<par id="parid(x)" value="?x" />
			<par id="parid(y)" value="?y" />
		    </call>
		    <call entity="bdash_main" event="new_explosion">
			<par id="parid(x)" value="?x" />
			<par id="parid(y)" value="?y" />
		    </call>
		    <stop />
		</if>
		<var name="anim" value="?anim-@elapsedticks" />
		<if eval="?anim<0">
		    <var name="anim" value="(?anim+1000)%200" />
		</if>
		<default propclass="?pcbb" />
		<lvar name="bd" value="?bdash_main.blockdim" />
		<lvar name="dim" value="(600-?anim)*#bd/600.0" />
	        <property id="propid(width)" value="#dim" />
	        <property id="propid(height)" value="#dim" />
		<lvar name="old_offset" value="?offset" />
		<var name="offset" value="(#bd-#dim)/2" />
		<property id="propid(x)" value="property(?pcbb,propid(x))-#old_offset+?offset" />
		<property id="propid(y)" value="property(?pcbb,propid(y))-#old_offset+?offset" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on an explosion in the
	  - boulderdash game.
	  -  ***************************************************** -->
        <script name="bdash_explosion">
	    <superscript name="bdash_block" />

	    <!--
	      - Initialize.
	      -->
	    <event name="init">
	        <createpropclass name="pctimer" />
	    	<super />
	    </event>

	    <event name="reinit">
	    	<super />
		<var name="counter" value="10" />
		<var name="explode" value="11" />	<!-- Don't explode -->
		<action propclass="pc(pctimer)" id="propid(WakeUp)">
		    <par id="parid(time)" value="20" />
		    <par id="parid(repeat)" value="true" />
		</action>
	    </event>
	    <event name="cleanup">
	        <super />
		<action propclass="pc(pctimer)" id="propid(Clear)" />
	    </event>

	    <!--
	      - Call this if you want this block to do a chain explosion
	      - a bit later.
	      -->
	    <event name="explode_later">
	    	<var name="explode" value="5" />
	    </event>

	    <event name="pctimer_wakeup">
	    	<var name="counter" value="?counter-1" />
		<if eval="?counter == ?explode">
		    <call entity="bdash_main" event="new_explosion">
			<par id="parid(x)" value="?x" />
			<par id="parid(y)" value="?y" />
		    </call>
		</if>
		<if eval="?counter == 0">
		    <call entity="bdash_main" event="clearblock_check">
			<par id="parid(x)" value="?x" />
			<par id="parid(y)" value="?y" />
		    </call>
		</if>
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a door.
	  -  ***************************************************** -->
        <script name="bdash_door">
	    <superscript name="bdash_block" />

	    <!--
	      - Initialize.
	      -->
	    <event name="init">
	    	<super />
		<!-- Push on door stack -->
		<!-- @@@ This code assumes doors cannot be destroyed and created later! -->
		<lvar name="ds" value="closedoor_stack+strsub(?blocktype,1,1)" />
		<var entity="bdash_main" name="#ds+?bdash_main.#ds" value="ent()" />
		<var entity="bdash_main" name="#ds" value="?bdash_main.#ds+1" />
	    </event>
	</script>

	<!-- *****************************************************
	  -  *****************************************************
	  - This is the boulderdash game editor script.
	  -  *****************************************************
	  -  ***************************************************** -->
	<script name="bdashedit_main">
	    <superscript name="bdash_main" />

	    <event name="init">
	    	<super />
	        <print value="EDITOR"/>

		<!-- Create the menu -->
		<var name="x" value="0" />
		<var name="y" value="0" />
		<expr eval="createmenuentity(blocktype='. ')" />
		<expr eval="createmenuentity(blocktype='HH')" />
		<expr eval="createmenuentity(blocktype='##')" />
		<expr eval="createmenuentity(blocktype='#B')" />
		<expr eval="createmenuentity(blocktype='#*')" />
		<expr eval="createmenuentity(blocktype='#+')" />
		<expr eval="createmenuentity(blocktype='#R')" />
		<expr eval="createmenuentity(blocktype='#W')" />
		<expr eval="createmenuentity(blocktype='XX')" />
		<expr eval="createmenuentity(blocktype='Xx')" />
		<expr eval="createmenuentity(blocktype='OO')" />
		<expr eval="createmenuentity(blocktype='Oo')" />
		<expr eval="createmenuentity(blocktype='Md')" />
		<expr eval="createmenuentity(blocktype='Ma')" />
		<expr eval="createmenuentity(blocktype='Mb')" />
		<expr eval="createmenuentity(blocktype='Mm')" />
		<expr eval="createmenuentity(blocktype='=L')" />
		<expr eval="createmenuentity(blocktype='=U')" />
		<expr eval="createmenuentity(blocktype='=1')" />
		<expr eval="createmenuentity(blocktype='=2')" />
		<expr eval="createmenuentity(blocktype='=3')" />
		<expr eval="createmenuentity(blocktype='=4')" />
		<expr eval="createmenuentity(blocktype='=a')" />
		<expr eval="createmenuentity(blocktype='=b')" />
		<expr eval="createmenuentity(blocktype='=c')" />
		<expr eval="createmenuentity(blocktype='=d')" />
		<expr eval="createmenuentity(blocktype='=+')" />
		<expr eval="createmenuentity(blocktype='=*')" />
		<expr eval="createmenuentity(blocktype='=R')" />
		<expr eval="createmenuentity(blocktype='=G')" />
		<expr eval="createmenuentity(blocktype='=B')" />
		<expr eval="createmenuentity(blocktype='=Y')" />
		<expr eval="createmenuentity(blocktype='=&')" />
		<expr eval="createmenuentity(blocktype='=|')" />
		<expr eval="createmenuentity(blocktype='=^')" />
		<expr eval="createmenuentity(blocktype='DO')" />
		<expr eval="createmenuentity(blocktype='DR')" />
		<expr eval="createmenuentity(blocktype='DG')" />
		<expr eval="createmenuentity(blocktype='DB')" />
		<expr eval="createmenuentity(blocktype='DY')" />
		<expr eval="createmenuentity(blocktype='KR')" />
		<expr eval="createmenuentity(blocktype='KG')" />
		<expr eval="createmenuentity(blocktype='KB')" />
		<expr eval="createmenuentity(blocktype='KY')" />
		<expr eval="createmenuentity(blocktype=':L')" />
		<expr eval="createmenuentity(blocktype=':U')" />
		<expr eval="createmenuentity(blocktype=':1')" />
		<expr eval="createmenuentity(blocktype=':2')" />
		<expr eval="createmenuentity(blocktype=':3')" />
		<expr eval="createmenuentity(blocktype=':4')" />
		<expr eval="createmenuentity(blocktype=':#')" />
		<expr eval="createmenuentity(blocktype=':%')" />
		<expr eval="createmenuentity(blocktype='>R')" />
		<expr eval="createmenuentity(blocktype='>L')" />
		<expr eval="createmenuentity(blocktype='>U')" />
		<expr eval="createmenuentity(blocktype='>D')" />
		<var name="lasty" value="?y" />

		<!-- Create the save button -->
		<inventory propclass="pc(pcinventory)" />
		<createentity name="save_button" behaviour="bdashedit_save" />
		<inventory_add child="ent(save_button)" />

		<!-- Create our hero -->
		<createentity name="hero" behaviour="bdash_hero_edit" />
		<inventory_add child="ent(hero)" />
	    </event>

	    <!--
	      - Create a menu entity. Parameters are
	      - @blocktype, ?x, and ?y.
	      -->
	    <event name="createmenuentity">
	        <lvar name="entname" value="menu_+@blocktype" />
		<createentity name="#entname" behaviour="bdashedit_menuitem" />
		<lvar name="ent" value="ent(#entname)" />
		<inventory propclass="pc(pcinventory)" />
		<inventory_add child="#ent" />
		<call entity="#ent" event="realinit">
		    <par id="parid(blocktype)" value="@blocktype" />
		    <par id="parid(x)" value="?x" />
		    <par id="parid(y)" value="?y" />
		</call>
		<var name="x" value="?x+1" />
		<if eval="?x>3"> <var name="x" value="0" /> <var name="y" value="?y+1" /> </if>
	    </event>

	    <!--
	      - Save the board.
	      -->
	    <event name="save">
		<for var="y" start="0" end="?dimension-1">
		    <lvar name="row" value="''" />
		    <for var="x" start="0" end="?dimension-1">
		    	<lvar name="ent" value="?maze[?x,?y]" />
			<lvar name="bt" value="'. '" />
			<if eval="#ent!=''">
			    <lvar name="bt" value="?#ent.blocktype" />
			</if>
		    	<lvar name="row" value="#row+#bt" />
		    </for>
		    <var name="row+?y" value="#row" />
		</for>
		<if eval="!writefile(row,'/cellib/objects/maze.txt',0,?dimension-1)">
		    <reporterror message="'Cannot write maze.txt!'" />
		</if>
	    </event>

	    <!--
	      - To avoid the entities from working we override createentity
	      - so that we can supply another behaviour.
	      - Create an entity with a given type. Possibly fetch it from the
	      - free entity stack. Parameter is @blocktype. Returns the entity.
	      -->
	    <event name="createentity">
	    	<lvar name="sn" value="entstack_+@blocktype" />
	        <if eval="?#sn > 0">
		    <lvar name="ent" value="?(#sn+?#sn)" />
		    <property propclass="?(#ent).pcbb" id="propid(visible)" value="true" />
		    <call entity="#ent" event="reinit" />
		    <var name="#sn" value="?(#sn)-1" />
		    <return value="#ent" />
		</if>
		<lvar name="entname" value="?entity_number" />
		<var name="entity_number" value="?entity_number+1" />
		<lvar name="bh" value="bdash_nonmovable" />
		<createentity name="#entname" behaviour="#bh" />
		<inventory propclass="pc(pcinventory)" />
		<lvar name="ent" value="ent(#entname)" />
		<inventory_add child="#ent" />
		<return value="#ent" />
	    </event>

	    <event name="initblock">
	        <lvar name="mazepos" value="maze_+?x+'_'+?y" />
	    	<if eval="?blocktype == 'HH'">
		    <var name="hero_start_x" value="?x" />
		    <var name="hero_start_y" value="?y" />
		    <var name="hero_x" value="?x" />
		    <var name="hero_y" value="?y" />
		</if>
	    	<if eval="?blocktype != '. '">
		    <var name="#mazepos" value="createentity(blocktype=?blocktype)" />
		    <stop />
		</if>
		<var name="#mazepos" value="''" />
	    </event>

	    <event name="ifempty_checkfall">
	    </event>
	    <event name="checkfall">
	    </event>

	</script>

	<!-- *****************************************************
	  - This script controls the behaviour of our hero in the editor.
	  -  ***************************************************** -->
	<script name="bdash_hero_edit">
	    <superscript name="movingobject" />

	    <!--
	      - Initialize our hero.
	      - Uses ?bdash_main.hero_start_x and ?bdash_main.hero_start_y for
	      - the hero start location.
	      -->
	    <event name="init">
		<var name="x" value="?bdash_main.hero_start_x" />
		<var name="y" value="?bdash_main.hero_start_y" />
		<var name="dim" value="?bdash_main.blockdim" />
		<var name="material" value="hero" />
		<var name="speed" value="?bdash_main.herospeed" />
		<super />
	        <var name="blocktype" value="'HH'" />
		<default propclass="?pcbb" />
	        <property id="propid(layer)" value="game" />
	        <createpropclass name="pckeyinput" />
		<default propclass="pc(pckeyinput)" />
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="right" />
		    <par id="parid(command)" value="move_right" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="left" />
		    <par id="parid(command)" value="move_left" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="up" />
		    <par id="parid(command)" value="move_up" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="down" />
		    <par id="parid(command)" value="move_down" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-right'" />
		    <par id="parid(command)" value="take_right" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-left'" />
		    <par id="parid(command)" value="take_left" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-up'" />
		    <par id="parid(command)" value="take_up" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="'shift-down'" />
		    <par id="parid(command)" value="take_down" />
		</action>
		<action id="propid(Bind)">
		    <par id="parid(trigger)" value="space" />
		    <par id="parid(command)" value="bomb" />
		</action>
	    </event>

	    <!--
	      - Routine used by the checktake events below to clear a block.
	      - Uses ?newx, and ?newy for the position of the block to clear.
	      -->
	    <event name="clearblock_check">
		<call entity="bdash_main" event="clearblock_check">
		    <par id="parid(x)" value="?newx" />
		    <par id="parid(y)" value="?newy" />
		</call>
	    </event>

	    <!--
	      - Routine used by the checkmove events below to clear a block.
	      - This version does not force a falling object check because
	      - it is supposed to be used when the player moves to the clear
	      - block.
	      - Uses ?newx, and ?newy for the position of the block to clear.
	      -->
	    <event name="clearblock_nocheck">
		<call entity="bdash_main" event="clearblock_nocheck">
		    <par id="parid(x)" value="?newx" />
		    <par id="parid(y)" value="?newy" />
		</call>
	    </event>

	    <!--
	      - Start moving the hero. This will set the block at
	      - ?x+?dx,?y+?dy to 'HH'.
	      -->
	    <event name="startmove">
	        <var name="oldx" value="?x" />
	        <var name="oldy" value="?y" />
	        <super />
		<var entity="bdash_main" name="hero_x" value="?x" />
		<var entity="bdash_main" name="hero_y" value="?y" />
	    </event>

	    <!--
	      - Our hero has stopped moving. This is called by the superscript
	      - and we use this to clear the block where the hero started from.
	      -->
	    <event name="endmove">
	    	<super />
		<var entity="bdash_main" name="layer_movetox"
			value="(?bdash_main.vis/2-?x)*?bdash_main.blockdim" />
		<var entity="bdash_main" name="layer_movetoy"
			value="(?bdash_main.vis/2-?y)*?bdash_main.blockdim" />
		<call entity="bdash_main" event="ifempty_checkfall">
		    <par id="parid(x)" value="?oldx" />
		    <par id="parid(y)" value="?oldy" />
	    	</call>
	    </event>

	    <!--
	      - Check if a move is possible and perform the move
	      - if so. Uses ?dx and ?dy to get the move direction and
	      - ?x and ?y for current position.
	      -->
	    <event name="checkmove">
	        <if eval="?moving">
		    <stop />
		</if>
		<var name="newx" value="?x+?dx" />
		<var name="newy" value="?y+?dy" />
		<if eval="?newx < 0 || ?newx >= ?bdash_main.dimension">
		    <stop />
		</if>
		<if eval="?newy < 0 || ?newy >= ?bdash_main.dimension">
		    <stop />
		</if>
		<call event="startmove" />
	    </event>

	    <event name="pckeyinput_move_right1">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_left1">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_down1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_up1">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_right_">
	    	<var name="dx" value="1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_left_">
	    	<var name="dx" value="-1" />
	    	<var name="dy" value="0" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_down_">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="1" />
		<call event="checkmove" />
	    </event>
	    <event name="pckeyinput_move_up_">
	    	<var name="dx" value="0" />
	    	<var name="dy" value="-1" />
		<call event="checkmove" />
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles all operations on a menu item.
	  -  ***************************************************** -->
        <script name="bdashedit_menuitem">
	    <!--
	      - Initialize this block.
	      -->
	    <event name="init">
	    </event>

	    <!--
	      - Real initialization. Uses @blocktype, @x, and @y parameters.
	      -->
	    <event name="realinit">
	        <var name="blocktype" value="@blocktype" />

	        <lvar name="dim" value="16000" />
	        <createpropclass name="pcbillboard" />
	        <createpropclass name="pcproperties" />
		<var name="pcbb" value="pc(pcbillboard)" />
		<default propclass="?pcbb" />
	        <property id="propid(name)" value="block" />
	        <property id="propid(materialname)" value="?bdash_main.material[?blocktype]" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="true" />
	        <property id="propid(restack)" value="false" />
	        <property id="propid(width)" value="#dim" />
	        <property id="propid(height)" value="#dim" />
	        <property id="propid(layer)" value="menu" />
	        <property id="propid(x)" value="240000+@x*(#dim+1000)" />
	        <property id="propid(y)" value="10000+@y*(#dim+1000)" />
	    </event>

	    <event name="pcbillboard_select">
	    	<lvar name="x" value="?bdash_main.hero_x" />
	    	<lvar name="y" value="?bdash_main.hero_y" />
		<call entity="bdash_main" event="clearblock_nocheck">
		    <par id="parid(x)" value="#x" />
		    <par id="parid(y)" value="#y" />
		</call>
		<call entity="bdash_main" event="createblock">
		    <par id="parid(blocktype)" value="?blocktype" />
		    <par id="parid(x)" value="#x" />
		    <par id="parid(y)" value="#y" />
		</call>
	    </event>
	</script>

	<!-- *****************************************************
	  - This script handles the save button.
	  -  ***************************************************** -->
        <script name="bdashedit_save">
	    <!--
	      - Initialize this block.
	      -->
	    <event name="init">
	        <createpropclass name="pcbillboard" />
	        <createpropclass name="pcproperties" />
		<var name="pcbb" value="pc(pcbillboard)" />
		<default propclass="?pcbb" />
	        <property id="propid(name)" value="block" />
	        <property id="propid(materialname)" value="save" />
	        <property id="propid(movable)" value="false" />
	        <property id="propid(clickable)" value="true" />
	        <property id="propid(restack)" value="false" />
	        <property id="propid(width)" value="16000*2" />
	        <property id="propid(height)" value="16000" />
	        <property id="propid(layer)" value="menu" />
	        <property id="propid(x)" value="240000" />
	        <property id="propid(y)" value="10000+(?bdash_main.lasty+2)*(16000+1000)" />
	    </event>

	    <event name="pcbillboard_select">
	    	<call entity="bdash_main" event="save" />
	    </event>
	</script>
    </addon>

    <addon plugin="celentity" entityname="menu">
        <behaviour name="menu" />
    </addon>
</world>

